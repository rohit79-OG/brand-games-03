<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>KS Endless Embrace - Fixed Completion</title>
    
<style>
/* =================================
   BASE STYLES
   ================================= */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
}

body {
    font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    color: #fff;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    position: relative;
    /* Stacking context for animated background */
    z-index: 1;
    margin: 0;
    padding: 0;
}

/* =================================
   GLASS MORPHISM COMPONENTS
   ================================= */

.glass {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
}

/* =================================
   SCREEN MANAGEMENT
   ================================= */

.screen {
    position: fixed;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    z-index: 10;
    top: 0;
    left: 0;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
}

.screen.active {
    display: flex;
    z-index: 100;
}

/* =================================
   GAME CANVAS & SCREEN
   ================================= */

#gameCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#threeCanvas {
    position: fixed;
    width: 100vw;
    height: 100vh;
    z-index: 10;
    pointer-events: none;
    top: 0;
    left: 0;
}

#particleCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 15 !important;
}

#gameScreen {
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    position: relative;
    transform-origin: center center;
    /* PHASE 3C: Smooth screen shake transitions */
    transition: transform 0.1s ease-out;
}

/* =================================
   START SCREEN
   ================================= */

.start-panel {
    padding: 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px auto;
    justify-content: center;
    min-height: auto;
}

/* =================================
   RESULTS SCREEN
   ================================= */

.results-panel {
    padding: 30px;
    max-width: 400px;
    width: 85%;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-height: 90vh;
    overflow-y: auto;
}

.results-panel h1 {
    margin-top: 20px !important;
    margin-bottom: 10px !important;
}

.results-panel .btn {
    padding: 12px 30px !important;
    font-size: clamp(0.9rem, 3.5vw, 1.1rem) !important;
    min-height: 48px !important;
    max-height: 55px !important;
}

#performanceMessage {
    font-size: clamp(1rem, 3.5vw, 1.1rem) !important;
    color: #FFFFFF !important;
    background: rgba(255, 215, 0, 0.1) !important;
    padding: 12px 16px !important;
    border-radius: 10px !important;
    margin: 15px 0 !important;
    border: 1px solid rgba(255, 215, 0, 0.3) !important;
    text-align: center !important;
    line-height: 1.4 !important;
    font-weight: 600 !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) !important;
}

/* Add after .results-panel styles */
.challenge-section {
    background: rgba(255, 255, 255, 0.05);
    padding: 12px;
    border-radius: 15px;
    margin: 10px 0;
    width: 100%;
}

.challenge-code {
    font-size: 1.5rem;
    font-weight: bold;
    color: #FFD700;
    letter-spacing: 2px;
    margin: 10px 0;
    text-align: center;
}

.couple-results {
    background: rgba(0, 0, 0, 0.3);
    padding: 15px;
    border-radius: 15px;
    margin: 15px 0;
    border: 1px solid rgba(255, 215, 0, 0.3);
}

.performance-comparison {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 15px 0;
}

.player-stats, .partner-stats {
    text-align: center;
    flex: 1;
}

.vs-indicator {
    color: #FFD700;
    font-weight: bold;
    margin: 0 15px;
    font-size: 1.2rem;
}

.combined-metrics {
    margin-top: 15px;
}

.metric {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-size: 0.9rem;
}

.metric .label {
    color: #fff;
}

.metric .value {
    color: #FFD700;
    font-weight: 600;
}

/* =================================
   TYPOGRAPHY
   ================================= */

h1 {
    font-size: clamp(2rem, 8vw, 3rem);
    text-align: center;
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

h2 {
    font-size: clamp(1.5rem, 6vw, 2rem);
    text-align: center;
    margin-bottom: 15px;
    color: #FFD700;
}

p {
    font-size: clamp(1rem, 4vw, 1.2rem);
    text-align: center;
    margin-bottom: 20px;
    line-height: 1.5;
}

/* =================================
   LOGOS
   ================================= */

.brand-logo {
    width: 150px;
    height: auto;
    margin-bottom: 20px;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

.game-logo {
    width: 80px;
    height: auto;
    margin-bottom: 10px;
    animation: pulse 2s ease-in-out infinite;
}

/* =================================
   BUTTONS
   ================================= */

.btn {
    background: linear-gradient(135deg, #d5365a 0%, #a0243d 100%);
    color: #fff;
    padding: 12px 30px !important;
    border: none;
    border-radius: 30px;
    font-size: clamp(1rem, 4vw, 1.2rem);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(213, 54, 90, 0.4);
    position: relative;
    overflow: hidden;
    margin: 10px auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    min-width: 140px !important;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2) !important;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(213, 54, 90, 0.5);
}

.btn-secondary {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.btn-gold {
    background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
    color: #1a0000;
    padding: 12px 25px;
    font-size: 0.9rem;
}

.btn-small {
    padding: 10px 20px;
    font-size: 0.9rem;
}

/* =================================
   GAME HUD
   ================================= */

.game-hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 20px;
    z-index: 1100;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-direction: column;
    pointer-events: none;
}

.hud-top {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: auto;
}

/* =================================
   TOP-POSITIONED MESSAGE SYSTEM
   ================================= */
.game-message {
    position: fixed;
    top: 120px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1500;
    
    width: 260px;
    max-width: 85vw;
    padding: 8px 16px;
    font-size: 0.75rem;
    
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    border: 2px solid rgba(255, 215, 0, 0.6);
    border-radius: 12px;
    text-align: center;
    
    animation: topMessageAppear 2.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
}

.game-message.milestone {
    border-color: rgba(255, 215, 0, 0.8);
    background: rgba(255, 215, 0, 0.1);
}

.game-message.combo {
    border-color: rgba(255, 107, 107, 0.8);
    background: rgba(255, 107, 107, 0.1);
}

.game-message.achievement {
    border-color: rgba(68, 255, 136, 0.8);
    background: rgba(68, 255, 136, 0.1);
}

.game-message.info {
    border-color: rgba(135, 206, 250, 0.8);
    background: rgba(135, 206, 250, 0.1);
}

@keyframes topMessageAppear {
    0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(-30px) scale(0.8); 
    }
    15% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0) scale(1.05); 
    }
    25% { 
        transform: translateX(-50%) translateY(0) scale(1); 
    }
    85% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(0) scale(1); 
    }
    100% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(-20px) scale(0.9); 
    }
}

@media (max-width: 768px) {
    .game-message {
        top: 100px;
        width: 260px;
        padding: 10px 16px;
        font-size: 0.9rem;
    }
}

/* =================================
   SCORE & INTIMACY METER
   ================================= */

.score-display, .intimacy-meter {
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 20px;
    font-size: 1.2rem;
    font-weight: 600;
}

.score-display {
    background: rgba(0, 0, 0, 0.7) !important;
    backdrop-filter: blur(15px) !important;
    border: 1px solid rgba(255, 215, 0, 0.3) !important;
    padding: 12px 20px !important;
    border-radius: 25px !important;
    font-size: 1.3rem !important;
    font-weight: 700 !important;
    color: #FFD700 !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5) !important;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3) !important;
}

.intimacy-meter {
    display: flex;
    gap: 5px;
    align-items: center;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* =================================
   HEARTS SYSTEM
   ================================= */

.heart {
    font-size: 1.5rem;
    transition: all 0.3s ease;
    position: relative;
    display: inline-block;
    cursor: default;
    color: #d5365a;
    text-shadow: 0 0 10px rgba(213, 54, 90, 0.5);
    margin: 0 2px;
}

.heart.active {
    color: #d5365a !important;
    text-shadow: 0 0 15px rgba(213, 54, 90, 0.8) !important;
    animation: heartBeat 1.5s ease-in-out infinite;
    transform-origin: center;
    opacity: 1 !important;
    filter: none !important;
}

.heart.inactive {
    color: #444 !important;
    opacity: 0.3 !important;
    animation: none !important;
    text-shadow: none !important;
    filter: grayscale(100%) !important;
}

/* =================================
   DISTRACTIONS
   ================================= */

.distraction {
    position: absolute;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 10 !important;
    animation: appearPop 0.3s ease-out;
    pointer-events: auto;
}

.distraction-icon {
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 3px solid #FFD700;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    position: relative;
    overflow: visible;
}

/* =================================
   SMOOTH SILHOUETTE TRANSITIONS
   ================================= */

.couple-silhouette {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) !important; 
    width: 300px;
    height: 300px;
    z-index: 2;
    opacity: 0.8;
    filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    overflow: hidden !important;      
    transform-origin: center center !important;
    
    transition: all 0.6s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
}

.couple-silhouette img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                opacity 0.6s ease-in-out,
                transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) !important;
    
    filter: brightness(1) contrast(1) saturate(1);
    transition-property: all, filter !important;
}

#coupleSilhouette {
    display: block !important;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2;
    pointer-events: none;
    opacity: 0.8;
}

.couple-silhouette.transitioning {
    filter: drop-shadow(0 0 30px rgba(213, 54, 90, 0.8)) !important;
    transform: translate(-50%, -50%) scale(1.05) !important;
}

.couple-silhouette.transitioning img {
    transform: scale(1.02) !important;
    filter: brightness(1.1) contrast(1.1) saturate(1.2) !important;
}

.silhouette-fade-out {
    opacity: 0 !important;
    transform: translate(-50%, -50%) scale(0.95) !important;
    filter: drop-shadow(0 0 10px rgba(213, 54, 90, 0.3)) !important;
}

.silhouette-fade-in {
    opacity: 0.8 !important;
    transform: translate(-50%, -50%) scale(1) !important;
    filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) !important;
}

/* =================================
   DIAGONAL TEAR EFFECT - FORCED SPECIFICITY
   ================================= */

/* Tear effect container */
.tear-overlay {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    pointer-events: none !important;
    z-index: 3 !important;
    opacity: 0 !important;
    overflow: hidden !important;
    transition: opacity 0.3s ease !important;
}

/* Two halves of the torn image */
.tear-half {
    position: absolute !important;
    width: 100% !important;
    height: 100% !important;
    background-size: contain !important;
    background-repeat: no-repeat !important;
    background-position: center !important;
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
    transform-origin: center center !important;
}

/* FORCED: Top-left half with guaranteed transforms */
.couple-silhouette .tear-half.top-left {
    clip-path: polygon(0% 0%, 85% 0%, 35% 85%, 0% 100%) !important;
    transform: translate(0, 0) rotate(0deg) !important;
}

/* FORCED: Bottom-right half with guaranteed transforms */
.couple-silhouette .tear-half.bottom-right {
    clip-path: polygon(35% 15%, 100% 0%, 100% 100%, 15% 100%) !important;
    transform: translate(0, 0) rotate(0deg) !important;
}

/* FORCED: Active tear animation with MAXIMUM specificity */
.couple-silhouette.tearing .tear-overlay {
    opacity: 1 !important;
    z-index: 4 !important;
}

.couple-silhouette.tearing .tear-half.top-left {
    transform: translate(-30px, -30px) rotate(-15deg) !important;
    filter: brightness(0.9) drop-shadow(8px 8px 15px rgba(0, 0, 0, 0.7)) !important;
}

.couple-silhouette.tearing .tear-half.bottom-right {
    transform: translate(30px, 30px) rotate(15deg) !important;
    filter: brightness(0.9) drop-shadow(-8px -8px 15px rgba(0, 0, 0, 0.7)) !important;
}

/* FORCED: Hide original image during tear */
.couple-silhouette.tearing img {
    opacity: 0 !important;
}

/* FORCED: Restoration phase */
.couple-silhouette.restoring .tear-overlay {
    opacity: 1 !important;
}

.couple-silhouette.restoring .tear-half.top-left {
    transform: translate(0, 0) rotate(0deg) !important;
    filter: brightness(1) drop-shadow(0 0 0 rgba(0, 0, 0, 0)) !important;
}

.couple-silhouette.restoring .tear-half.bottom-right {
    transform: translate(0, 0) rotate(0deg) !important;
    filter: brightness(1) drop-shadow(0 0 0 rgba(0, 0, 0, 0)) !important;
}

/* FORCED: Mobile optimizations */
@media (max-width: 768px) {
    .couple-silhouette.tearing .tear-half.top-left {
        transform: translate(-25px, -25px) rotate(-12deg) !important;
    }
    
    .couple-silhouette.tearing .tear-half.bottom-right {
        transform: translate(25px, 25px) rotate(12deg) !important;
    }
}

/* =================================
   AUDIO TOGGLE
   ================================= */

.audio-toggle {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1200;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    touch-action: manipulation !important; 
    -webkit-touch-callout: none !important; 
    -webkit-user-select: none !important; 
    user-select: none !important;
}

.audio-toggle:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.audio-toggle.muted {
    opacity: 0.6;
    background: rgba(255, 0, 0, 0.2) !important;
}

/* =================================
   ANIMATIONS
   ================================= */

@keyframes heartBeat {
    0%, 100% { 
        transform: scale(1);
    }
    14% { 
        transform: scale(1.1);
    }
    28% { 
        transform: scale(1);
    }
    42% { 
        transform: scale(1.1);
    }
    70% { 
        transform: scale(1);
    }
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

@keyframes appearPop {
    0% { transform: scale(0); opacity: 0; }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
}

/* =================================
   LOADING SCREEN
   ================================= */

.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #1a0000 0%, #3a0000 50%, #d5365a 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
}

.loading-bar {
    width: 80%;
    max-width: 300px;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 20px;
}

.loading-progress {
    height: 100%;
    background: linear-gradient(90deg, #d5365a 0%, #FFD700 100%);
    border-radius: 2px;
    transition: width 0.3s ease;
}

/* =================================
   PRODUCT DISPLAY
   ================================= */

.product-display {
    width: 150px;
    height: auto;
    margin: 10px;
    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.3));
}

.qr-code {
    width: 150px;
    height: 150px;
    background: transparent !important;
    padding: 0;
    border-radius: 8px;
    margin: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none !important;
    box-shadow: none !important;
}

.image-row {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    margin: 25px 0;
}

.button-row {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin: 25px 0;
}

.share-buttons {
    display: flex;
    gap: 15px;
    margin-top: 30px;
    flex-wrap: wrap;
    justify-content: center;
}

.share-btn {
    background: rgba(255, 255, 255, 0.2);
    padding: 10px 20px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.share-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
}

.milestone-notification {
    display: none !important;
}

@keyframes safeMissSmooth {
    0% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    }
    25% { 
        transform: translate(-50%, -50%) scale(1.08);
        filter: drop-shadow(0 0 25px rgba(213, 54, 90, 0.7));
    }
    50% { 
        transform: translate(-50%, -50%) scale(0.96);
        filter: drop-shadow(0 0 15px rgba(213, 54, 90, 0.4));
    }
    75% { 
        transform: translate(-50%, -50%) scale(1.02);
        filter: drop-shadow(0 0 22px rgba(213, 54, 90, 0.6));
    }
    100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5));
    }
}

@keyframes dangerMissSmooth {
    0% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) hue-rotate(0deg);
    }
    20% { 
        transform: translate(-50%, -50%) scale(1.12);
        filter: drop-shadow(0 0 30px rgba(255, 68, 68, 0.8)) hue-rotate(15deg);
    }
    40% { 
        transform: translate(-50%, -50%) scale(0.92);
        filter: drop-shadow(0 0 35px rgba(255, 100, 100, 0.9)) hue-rotate(-10deg);
    }
    60% { 
        transform: translate(-50%, -50%) scale(1.06);
        filter: drop-shadow(0 0 25px rgba(255, 68, 68, 0.7)) hue-rotate(8deg);
    }
    80% { 
        transform: translate(-50%, -50%) scale(0.98);
        filter: drop-shadow(0 0 22px rgba(213, 54, 90, 0.6)) hue-rotate(-5deg);
    }
    100% { 
        transform: translate(-50%, -50%) scale(1);
        filter: drop-shadow(0 0 20px rgba(213, 54, 90, 0.5)) hue-rotate(0deg);
    }
}

.distraction-high {
    animation: urgentPulse 0.6s ease-in-out infinite;
}

.distraction-medium {
    animation: moderatePulse 1s ease-in-out infinite;
}

.distraction-low {
    animation: calmPulse 1.8s ease-in-out infinite;
}

.urgency-high .distraction-icon {
    border-color: #ff4444 !important;
    box-shadow: 0 4px 20px rgba(255, 68, 68, 0.7) !important;
    background: rgba(255, 68, 68, 0.1) !important;
}

.urgency-medium .distraction-icon {
    border-color: #ffaa00 !important;
    box-shadow: 0 4px 15px rgba(255, 170, 0, 0.6) !important;
    background: rgba(255, 170, 0, 0.1) !important;
}

.urgency-low .distraction-icon {
    border-color: #44ff88 !important;
    box-shadow: 0 4px 12px rgba(68, 255, 136, 0.5) !important;
    background: rgba(68, 255, 136, 0.1) !important;
}

.point-popup {
    animation: pointFloat 1.2s ease-out forwards;
    font-family: 'Poppins', sans-serif;
    z-index: 200;
}

.point-text {
    color: #FFD700;
    font-weight: bold;
    font-size: 1.4rem;
    text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.8);
    display: inline-block;
}

.combo-text {
    color: #ff6b6b;
    font-size: 0.9em;
    margin-left: 5px;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
}

.urgency-high .point-text {
    color: #ff6b6b;
    text-shadow: 0 0 10px rgba(255, 107, 107, 0.8);
}

.urgency-medium .point-text {
    color: #ffa726;
    text-shadow: 0 0 8px rgba(255, 167, 38, 0.6);
}

.urgency-low .point-text {
    color: #66bb6a;
    text-shadow: 0 0 6px rgba(102, 187, 106, 0.5);
}

@keyframes urgentPulse {
    0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 4px 20px rgba(255, 68, 68, 0.7);
    }
    50% { 
        transform: scale(1.2); 
        box-shadow: 0 6px 25px rgba(255, 68, 68, 0.9);
    }
}

@keyframes moderatePulse {
    0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 4px 15px rgba(255, 170, 0, 0.6);
    }
    50% { 
        transform: scale(1.1); 
        box-shadow: 0 5px 18px rgba(255, 170, 0, 0.8);
    }
}

@keyframes calmPulse {
    0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 4px 12px rgba(68, 255, 136, 0.5);
    }
    50% { 
        transform: scale(1.06); 
        box-shadow: 0 4px 15px rgba(68, 255, 136, 0.7);
    }
}

@keyframes pointFloat {
    0% { 
        opacity: 1; 
        transform: translateY(0) scale(1); 
    }
    30% {
        opacity: 1;
        transform: translateY(-15px) scale(1.2);
    }
    100% { 
        opacity: 0; 
        transform: translateY(-60px) scale(0.8); 
    }
}

/* =================================
   PRIORITY DISTRACTION SYSTEM
   ================================= */

/* Override existing distraction-icon to be circular with glassmorphism */
.distraction-icon {
    width: 80px !important;
    height: 80px !important;
    
    /* Glassmorphism Background */
    background: rgba(255, 255, 255, 0.15) !important;
    backdrop-filter: blur(15px) !important;
    -webkit-backdrop-filter: blur(15px) !important;
    
    /* Force Circular Shape */
    border-radius: 50% !important;
    
    /* Border */
    border: 2px solid rgba(255, 255, 255, 0.3) !important;
    
    /* Glass Shadow */
    box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.37),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
    
    /* Content Styling */
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 2.2rem !important;
    position: relative !important;
    overflow: visible !important;
    
    /* Smooth Transitions */
    transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
    
    /* Performance */
    will-change: transform;
    transform: translateZ(0);
}

/* =================================
   PRIORITY RING SYSTEM
   ================================= */

.priority-ring {
    position: absolute;
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    border-radius: 50%;
    border: 4px solid transparent;
    pointer-events: none;
    z-index: 5;
    opacity: 0.9;
    will-change: transform, opacity;
    transform: translateZ(0);
}

/* Critical Priority Ring (High Urgency) */
.priority-ring.critical {
    border: 6px solid #FF4444;
    animation: criticalRingIntense 0.4s ease-in-out infinite;
    box-shadow: 
        0 0 25px rgba(255, 68, 68, 1),
        inset 0 0 15px rgba(255, 68, 68, 0.3);
}

/* Warning Priority Ring (Medium Urgency) */
.priority-ring.warning {
    border: 4px solid #FFA500;
    animation: warningRingMedium 0.8s ease-in-out infinite;
    box-shadow: 
        0 0 20px rgba(255, 165, 0, 0.8),
        inset 0 0 12px rgba(255, 165, 0, 0.2);
}

/* Safe Priority Ring (Low Urgency) */
.priority-ring.safe {
    border: 3px solid #32CD32;
    animation: safeRingGentle 1.5s ease-in-out infinite;
    box-shadow: 
        0 0 15px rgba(50, 205, 50, 0.6),
        inset 0 0 8px rgba(50, 205, 50, 0.1);
}

/* =================================
   PRIORITY RING ANIMATIONS
   ================================= */

@keyframes criticalRingIntense {
    0%, 100% { 
        transform: scale(1); 
        opacity: 1;
        border-width: 6px;
    }
    50% { 
        transform: scale(1.15); 
        opacity: 0.8;
        border-width: 8px;
    }
}

@keyframes warningRingMedium {
    0%, 100% { 
        transform: scale(1); 
        opacity: 0.9;
        border-width: 4px;
    }
    50% { 
        transform: scale(1.1); 
        opacity: 0.7;
        border-width: 5px;
    }
}

@keyframes safeRingGentle {
    0%, 100% { 
        transform: scale(1); 
        opacity: 0.8;
        border-width: 3px;
    }
    50% { 
        transform: scale(1.05); 
        opacity: 0.6;
        border-width: 4px;
    }
}

/* =================================
    URGENCY STYLING
   ================================= */

/* High Urgency - Critical (Override existing) */
.urgency-high .distraction-icon {
    background: rgba(255, 68, 68, 0.25) !important;
    border-color: rgba(255, 68, 68, 0.7) !important;
    box-shadow: 
        0 8px 32px rgba(255, 68, 68, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

/* Medium Urgency - Warning (Override existing) */
.urgency-medium .distraction-icon {
    background: rgba(255, 165, 0, 0.25) !important;
    border-color: rgba(255, 165, 0, 0.7) !important;
    box-shadow: 
        0 8px 32px rgba(255, 165, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

/* Low Urgency - Safe (Override existing) */
.urgency-low .distraction-icon {
    background: rgba(50, 205, 50, 0.25) !important;
    border-color: rgba(50, 205, 50, 0.7) !important;
    box-shadow: 
        0 8px 32px rgba(50, 205, 50, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1) !important;
}

/* =================================
   TROPHY BONUS DISTRACTIONS
   ================================= */

.distraction-icon.trophy {
    background: linear-gradient(45deg, 
        rgba(255, 215, 0, 0.3) 0%, 
        rgba(255, 165, 0, 0.25) 50%, 
        rgba(255, 140, 0, 0.2) 100%) !important;
    border: 3px solid rgba(255, 255, 0, 0.8) !important;
    box-shadow: 
        0 0 30px rgba(255, 215, 0, 0.8),
        0 8px 32px rgba(255, 215, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2) !important;
    animation: trophyPulse 1.5s ease-in-out infinite !important;
    backdrop-filter: blur(20px) !important;
}

.trophy-bonus {
    position: absolute;
    top: -22px;
    left: 50%;
    transform: translateX(-50%);
    
    /* Glassmorphism Badge */
    background: rgba(255, 215, 0, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    
    color: #000;
    font-size: 0.7rem;
    font-weight: bold;
    padding: 4px 8px;
    border-radius: 12px;
    border: 1px solid rgba(255, 165, 0, 0.8);
    white-space: nowrap;
    z-index: 15;
    pointer-events: none;
    
    box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    
    animation: bonusBadgePulse 2s ease-in-out infinite;
}

@keyframes trophyPulse {
    0%, 100% { 
        transform: scale(1) rotate(0deg);
        box-shadow: 
            0 0 30px rgba(255, 215, 0, 0.8),
            0 8px 32px rgba(255, 215, 0, 0.4);
    }
    50% { 
        transform: scale(1.1) rotate(2deg);
        box-shadow: 
            0 0 40px rgba(255, 215, 0, 1),
            0 10px 40px rgba(255, 215, 0, 0.6);
    }
}

@keyframes bonusBadgePulse {
    0%, 100% { 
        transform: translateX(-50%) scale(1);
        opacity: 1;
    }
    50% { 
        transform: translateX(-50%) scale(1.05);
        opacity: 0.9;
    }
}

/* =================================
   STICKY NOTES (NO PRIORITY RINGS)
   ================================= */

.sticky-note {
    width: 100px;
    height: 80px;
    position: relative;
    cursor: pointer;
    z-index: 10;
    
    /* Glassmorphism Sticky Note */
    background: rgba(255, 235, 59, 0.9) !important;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    
    /* Realistic Paper Effect */
    transform: rotate(-5deg);
    box-shadow: 
        2px 2px 15px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    
    /* Content Styling */
    padding: 12px;
    font-family: 'Comic Sans MS', 'Chalkduster', cursive !important;
    font-size: 11px;
    color: #333;
    line-height: 1.2;
    
    /* Smooth Transitions */
    transition: all 0.3s ease;
    
    /* Border */
    border: 1px solid rgba(255, 193, 7, 0.4);
    border-radius: 4px;
}

.sticky-note:hover {
    transform: rotate(-2deg) scale(1.05);
    box-shadow: 
        4px 4px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

/* Tape Effect on Sticky Notes */
.sticky-note:before {
    content: '';
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 16px;
    
    /* Glassmorphism Tape */
    background: rgba(255, 255, 255, 0.3);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.sticky-note div {
    font-family: 'Comic Sans MS', 'Chalkduster', cursive !important;
    font-size: 10px !important;
    line-height: 1.2 !important;
    color: #333 !important;
}

/* =================================
   HOVER EFFECTS
   ================================= */

.distraction:hover .distraction-icon {
    transform: scale(1.1);
    box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.5),
        inset 0 2px 0 rgba(255, 255, 255, 0.2) !important;
}

.distraction:hover .priority-ring {
    transform: scale(1.1);
    opacity: 1;
}

/* =================================
   MOBILE OPTIMIZATIONS
   ================================= */

@media (max-width: 768px) {
    .distraction-icon {
        width: 70px !important;
        height: 70px !important;
        font-size: 2rem !important;
    }
    
    .priority-ring {
        top: -6px;
        left: -6px;
        right: -6px;
        bottom: -6px;
    }
    
    .trophy-bonus {
        font-size: 0.6rem;
        padding: 3px 6px;
        top: -18px;
    }
    
    .sticky-note {
        width: 85px;
        height: 70px;
        font-size: 10px;
        padding: 8px;
    }
    
    .sticky-note div {
        font-size: 9px !important;
    }
}

/* ========================================================================
   PHASE 3C: ACHIEVEMENT SYSTEM - GAME-THEMED STYLES
   ======================================================================== */

#achievementGallery {
    position: fixed;
    top: 80px; /* Below score section */
    left: 15px;
    width: 240px; /* Smaller width */
    max-height: 45vh; /* Reduced height */
    z-index: 1000;
    
    /* Game color scheme glassmorphism */
    background: rgba(26, 0, 0, 0.7); /* Match game's dark red */
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(213, 54, 90, 0.3); /* Match game's accent color */
    border-radius: 12px; /* Smaller radius */
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    
    /* Smooth transitions */
    transition: all 0.3s ease;
    opacity: 0.9;
    
    /* Scrollable content */
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

#achievementGallery:hover {
    opacity: 1;
    transform: translateY(-1px);
    box-shadow: 0 6px 25px rgba(213, 54, 90, 0.2);
}

.achievement-header {
    padding: 12px 15px 10px 15px; /* Smaller padding */
    border-bottom: 1px solid rgba(213, 54, 90, 0.2);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.achievement-header h3 {
    margin: 0;
    font-size: 14px; /* Smaller font */
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

.achievement-count {
    background: rgba(213, 54, 90, 0.2); /* Game color scheme */
    padding: 4px 8px; /* Smaller padding */
    border-radius: 8px;
    font-size: 11px; /* Smaller font */
    font-weight: 600;
    color: #fff;
    border: 1px solid rgba(213, 54, 90, 0.3);
}

.achievement-list {
    padding: 8px; /* Smaller padding */
    overflow-y: auto;
    flex: 1;
    
    /* Custom scrollbar */
    scrollbar-width: thin;
    scrollbar-color: rgba(213, 54, 90, 0.4) transparent;
}

.achievement-list::-webkit-scrollbar {
    width: 4px;
}

.achievement-list::-webkit-scrollbar-track {
    background: transparent;
}

.achievement-list::-webkit-scrollbar-thumb {
    background: rgba(213, 54, 90, 0.4);
    border-radius: 2px;
}

.achievement-item {
    display: flex;
    align-items: center;
    padding: 8px; /* Smaller padding */
    margin-bottom: 6px;
    border-radius: 8px;
    transition: all 0.3s ease;
    border: 1px solid transparent;
}

.achievement-item.unlocked {
    background: rgba(213, 54, 90, 0.25); /* Game color scheme */
    border-color: rgba(255, 215, 0, 0.6); /* Golden border */
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); /* Golden glow */
}

.achievement-item.locked {
    background: rgba(58, 0, 0, 0.3); /* Match game's dark theme */
    border-color: rgba(213, 54, 90, 0.1);
}

.achievement-item:hover {
    transform: translateX(2px);
    background: rgba(213, 54, 90, 0.15);
}

.achievement-icon {
    font-size: 18px; /* Smaller icon */
    margin-right: 8px;
    width: 24px;
    text-align: center;
}

.achievement-item.unlocked .achievement-icon {
    filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8)); /* Golden glow for unlocked */
}

.achievement-item.locked .achievement-icon {
    filter: grayscale(100%) opacity(0.4);
}

.achievement-info {
    flex: 1;
}

.achievement-name {
    font-size: 11px; /* Smaller font */
    font-weight: 600;
    color: #fff;
    margin-bottom: 1px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

.achievement-item.unlocked .achievement-name {
    color: #ffd700; /* Golden text for unlocked */
    text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
}

.achievement-item.locked .achievement-name {
    color: rgba(255, 255, 255, 0.5);
}

.achievement-description {
    font-size: 9px; /* Smaller font */
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 6px;
    line-height: 1.2;
}

.achievement-item.locked .achievement-description {
    color: rgba(255, 255, 255, 0.3);
}

.achievement-progress {
    display: flex;
    align-items: center;
    gap: 6px;
}

/* Hide achievement panel on non-game screens */
.screen:not(#gameScreen) #achievementGallery {
    display: none !important;
}

/* Show achievement panel only during gameplay */
#gameScreen #achievementGallery {
    display: flex !important;
}

.progress-bar {
    flex: 1;
    height: 3px; /* Smaller height */
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #d5365a, #ff6b6b); /* Game color scheme */
    border-radius: 2px;
    transition: width 0.3s ease;
}

.achievement-item.unlocked .progress-fill {
    background: linear-gradient(90deg, #ffd700, #ffed4e); /* Golden for unlocked */
}

.achievement-item.locked .progress-fill {
    background: rgba(255, 255, 255, 0.3);
}

.progress-text {
    font-size: 9px; /* Smaller font */
    color: rgba(255, 255, 255, 0.6);
    font-weight: 500;
    min-width: 25px;
    text-align: right;
}

/* Mobile Responsive - Hide on small screens */
@media (max-width: 768px) {
    #achievementGallery {
        display: none;
    }
}

/* Force hide achievement panel on mobile - Higher specificity */
@media (max-width: 768px) {
    #achievementGallery,
    #gameScreen #achievementGallery,
    .screen #achievementGallery {
        display: none !important;
    }
}

</style>

</head>
<body>
    <!-- Loading Screen -->
<div id="loadingScreen" class="loading-screen">
    <div class="glass" style="padding: 40px; max-width: 500px; width: 90%; text-align: center;">
        <img src="https://assets.codepen.io/t-24779/KS_logo_two.png" alt="KamaSutra" class="brand-logo">
        <h2>Loading Endless Embrace...</h2>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <p id="loadingTip" style="margin-top: 20px; font-size: 0.9rem; opacity: 0.8;"></p>
    </div>
</div>

<!-- Start Screen -->
<div id="startScreen" class="screen">
    <div class="glass start-panel">
        <img src="https://assets.codepen.io/t-24779/KS_logo_two.png" alt="KamaSutra" class="brand-logo">
        <h1>Endless Embrace</h1>
        <img src="https://assets.codepen.io/t-24779/bg-seated-embrace-pose.png" alt="Endless Embrace" class="game-logo">
        <p style="color: #FFD700; font-size: 1.2rem; margin: 20px 0;">Kill the mood killers. Last longer!</p>
        <button class="btn" onclick="startGame()">Play Game</button>
    </div>
</div>

<!-- Game Screen -->
<div id="gameScreen" class="screen">
    <canvas id="gameCanvas"></canvas>
    <div id="threeContainer" style="position: absolute; width: 100%; height: 100%; z-index: 2; pointer-events: none;"></div>
    <div class="couple-silhouette" id="coupleSilhouette">
        <img id="silhouetteImage" src="https://assets.codepen.io/t-24779/hug-embrace.png" alt="Couple">
    </div>
    <div class="game-hud">
        <div class="hud-top">
            <div class="score-display">
                Score: <span id="score">0</span>
            </div>
            <div class="intimacy-meter" id="intimacyMeter">
                <span class="heart active">❤️</span>
                <span class="heart active">❤️</span>
                <span class="heart active">❤️</span>
                <span class="heart active">❤️</span>
                <span class="heart active">❤️</span>
            </div>
        </div>
    </div>
    <div class="audio-toggle" id="audioToggle" onclick="toggleAudio()">
        <span id="audioIcon">🔊</span>
    </div>
</div>

<!-- Results Screen -->
<div id="resultsScreen" class="screen">
    <div class="glass results-panel">
        <h1 style="color: #d5365a; margin-bottom: 10px; font-size: 2.5rem;">GAME OVER</h1>
        <p style="font-size: 2rem; color: #FFD700; margin-bottom: 20px;">
            Score: <span id="finalScore">0</span>
        </p>
        <p id="performanceMessage" style="margin-bottom: 20px;">Your embrace was amazing! Thanks for playing!</p>

        <div class="image-row">
            <div class="qr-code" id="qrCode">
                <!-- QR Code will be generated here -->
            </div>
            <img src="https://assets.codepen.io/t-24779/KamaSutra-longlast-product.png" alt="KamaSutra LongLast" class="product-display" style="height: 150px; width: auto;">
        </div>
        
        <div class="button-row">
            <button class="btn btn-gold btn-small" onclick="saveQRCode()">Save Code</button>
            <a href="https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756" target="_blank" class="btn btn-gold btn-small" style="text-decoration: none;">
                Passion 3X  
            </a>
        </div>
        
        <p style="font-size: 1rem; margin: 15px 0;">
            For longer lasting moments, choose KamaSutra LongLast.<br>
            <span style="color: #FFD700; font-weight: bold;">3X Longer Lasting!</span>
        </p>

        <!-- Couple Challenge Section -->
        <div class="challenge-section">
            <p style="font-size: 0.9rem; margin-bottom: 10px;">🔥 Couple Challenge Mode 🔥</p>
            <div class="challenge-code" id="challengeCode">------</div>
            <div id="coupleStatus" style="margin: 10px 0; display: none;">
                <p style="font-size: 0.8rem;" id="challengeStatusText"></p>
            </div>
            <button class="btn btn-secondary btn-small" onclick="generateChallengeCode()">Generate Challenge Code</button>
            <button class="btn btn-secondary btn-small" onclick="showEnterCode()" style="margin-top: 5px;">Enter Partner's Code</button>
        </div>

        <!-- Couple Results Display -->
        <div class="couple-results" id="coupleResults" style="display: none;">
            <h3 style="color: #FFD700;">💕 Couple Challenge Results</h3>
            <div class="performance-comparison">
                <div class="player-stats">
                    <h4>You</h4>
                    <div class="score" id="yourScore">0</div>
                </div>
                <div class="vs-indicator">VS</div>
                <div class="partner-stats">
                    <h4>Partner</h4>
                    <div class="score" id="partnerScore">0</div>
                </div>
            </div>
            <div class="combined-metrics">
                <h4>Together You Achieved:</h4>
                <div class="metric">
                    <span class="label">Total Score:</span>
                    <span class="value" id="totalScore">0</span>
                </div>
                <div class="metric">
                    <span class="label">Harmony Level:</span>
                    <span class="value" id="harmonyLevel">-</span>
                </div>
                <div class="metric">
                    <span class="label">Combined Time:</span>
                    <span class="value" id="combinedTime">0s</span>
                </div>
            </div>
        </div>

        <div class="share-buttons">
            <div class="share-btn" onclick="shareWhatsApp()">
                <span>📱</span>
                <span>WhatsApp</span>
            </div>
        </div>
        
        <button class="btn" style="margin-top: 20px;" onclick="restartGame()">Play Again</button>
    </div>
</div>

    <!-- QR Code Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
<script>
// ========================================================================
// GAME STATE SYSTEM
// ========================================================================
const gameState = {
    currentScreen: 'loading',
    score: 0,
    lives: 5,
    gameRunning: false,
    gameEnding: false,
    gameStartTime: 0,
    distractions: [],
    audioEnabled: true,
    isMobile: innerWidth <= 768,
    currentSilhouetteLevel: 1,
    combo: 0,
    lastEliminationTime: 0,
    totalDistractions: 0,
    eliminatedDistractions: 0,
    audioContextStarted: false, // Track audio context state
    animationFrame: null, // MOVEMENT SYSTEM
    level: 1,                   
    challengeCode: null,       
    perfectRounds: 0,          
    sessionId: Date.now(),

    cleanup() {
    console.log('🧹 Simple game cleanup...');
    this.gameRunning = false;
    this.gameEnding = false;
    
    this.distractions.forEach(d => {
        if (d && d.parentNode) d.remove();
    });
    this.distractions = [];
    
    const distractionElements = document.querySelectorAll('.distraction');
    distractionElements.forEach(el => el.remove());
    
    // PHASE 3C: Clean up screen shake
    if (typeof screenShake !== 'undefined') {
        screenShake.stop();
        console.log('📳 Screen shake cleanup completed');
    }
    
    // PHASE 3C: Clean up animated background
    if (typeof backgroundEffects !== 'undefined') {
        backgroundEffects.destroy();
        console.log('🌟 Background effects cleanup completed');
    }
    
    // PHASE 3C: Clean up achievement system
    if (typeof achievementSystem !== 'undefined') {
        achievementSystem.destroy();
        console.log('🏆 Achievement system cleanup completed');
    }
    
    // PHASE 3C: Clean up analytics system
    if (typeof analyticsSystem !== 'undefined') {
        analyticsSystem.destroy();
        console.log('📊 Analytics system cleanup completed');
    }

    // Clean up body-level tear effects
    const bodyTear = document.getElementById('bodyTearEffect');
    if (bodyTear) {
        bodyTear.remove();
        console.log('🧹 Body-level tear effect cleanup completed');
    }

    // Clean up all tear effects
       tearCleanupManager.forceCleanupAll();
       tearStateManager.isExecuting = false;
       tearStateManager.currentTearId = null;
       console.log('🧹 Tear system cleanup completed');

    // Clean up & stop background music during cleanup
    if (typeof audioManager !== 'undefined' && audioManager.stopBackgroundMusic) {
        audioManager.stopBackgroundMusic();
        console.log('🎵 Background music stopped during cleanup');
    }

    // Animation frame cleanup
    if (this.animationFrame) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
        console.log('🎬 Animation frame cleanup completed');
    }

  },
    
    reset() {
    this.cleanup();
    this.score = 0;
    this.lives = 5;
    this.gameEnding = false;
    this.combo = 0;
    this.lastEliminationTime = 0;
    this.totalDistractions = 0;
    this.eliminatedDistractions = 0;
    this.currentSilhouetteLevel = 1;
    this.level = 1;
    this.challengeCode = null;
    this.perfectRounds = 0;
    this.sessionId = Date.now();

    // PHASE 3C: Reset achievement tracking for new game
    if (typeof achievementSystem !== 'undefined') {
        achievementSystem.reset();
    }

    // PHASE 3C: Reset analytics tracking for new game
    if (typeof analyticsSystem !== 'undefined') {
    analyticsSystem.reset();
    }
    console.log('🔄 Game state reset');
}
};

// ========================================================================
// PROGRESSIVE SILHOUETTE SYSTEM
// ========================================================================
const progressiveSilhouettes = [
    { threshold: 0, name: "Tender Beginning", url: "https://assets.codepen.io/t-24779/hug-embrace.png", level: 1 },
    { threshold: 150, name: "First Flow", url: "https://assets.codepen.io/t-24779/romantic-embrace.png", level: 2 },
    { threshold: 300, name: "Getting Intense", url: "https://assets.codepen.io/t-24779/lap-embrace.png", level: 3 },
    { threshold: 500, name: "Heart Recovery", url: "https://assets.codepen.io/t-24779/standing-embrace.png", level: 4 },
    { threshold: 750, name: "Skill Master", url: "https://assets.codepen.io/t-24779/stand-embrace.png", level: 5 },
    { threshold: 1000, name: "Power Player", url: "https://assets.codepen.io/t-24779/held-up-lap-embrace.png", level: 6 },
    { threshold: 1500, name: "Legendary", url: "https://assets.codepen.io/t-24779/stand-kiss-embrace.png", level: 7 },
    { threshold: 2000, name: "Ultimate Intimacy", url: "https://assets.codepen.io/t-24779/holding-embrace.png", level: 8 }
];
// ========================================================================
// STATIC DATA ARRAYS  
// ========================================================================
const loadingTips = [
    "💡 Pro tip: Lasting longer starts with the right preparation... 😉",
    "🎯 Focus is everything - in games and in life! #LongLast3X",
    "🔥 Some moments deserve to last 3X longer... just saying",
    "💪 Protect your moments. Embrace Up 3X.",
    "⚡ The best performances require the right preparation"
];

const hinglishTemplates = [
    "Yaar, maine {score} points banaye! 💪 Tera stamina kitna hai? 😏 #LongLast3X",
    "Boss, {time} seconds tak tika raha! 🔥 Tu kitna der chalega? 😎 #EndlessEmbrace",
    "Mera score dekh: {score}! 🏆 Teri baari ab... himmat hai? 😈 #3XPower",
    "Bhai, streak toh dekh: {streak} 🔥🔥 Beat kar sake toh kar! 💯 #StaminaKing",
    "Distraction ka baap hun main! 🎯 Score: {score} - tera kya scene? 🤔",
    "3X warrior ban gaya! ⚡ {score} points! Chal competition karte hai 😏",
    "Mast game hai yaar! 🎮 {time} seconds survive kiya... tu try kar! 💪",
    "Kya focus hai mera! 🧘‍♂️ Score {score}! Tere paas hai dum? 🔥",
    "Endless embrace mein {score} banaye! 💕 Partner ke saath khelo, maza aayega 😉",
    "Stamina check kar apna! 💯 Mera score: {score} - challenge accept? 🎯",
    "Power packed performance! 💥 {time} seconds! Teri turn ab 😎 #3XLonger",
    "Distraction destroyer! 🔥 Score {score}! Aa jaa ring mein 🥊 #EndlessEmbrace"
];

const coupleSharingTemplates = [
    "Couple power! 💑 Total score: {totalScore}! Harmony: {harmonyLevel} 💕 Combined time: {combinedTime}s! #CoupleGoals #LongLast3X",
    "Partner ke saath {totalScore} points! 🔥 Harmony level: {harmonyLevel} ❤️ Time: {combinedTime}s - Beat this! 😎",
    "Double trouble! 💪 Score {totalScore}, Harmony {harmonyLevel} 💕 {combinedTime} seconds of pure focus! #PowerCouple",
    "Couple challenge complete! 🏆 {totalScore} combined! {harmonyLevel} connection 💖 Challenge us: {challengeCode}",
    "Partner aur main = {totalScore} points! 🔥 {harmonyLevel} sync! Time {combinedTime}s 💪 #EndlessEmbrace",
    "Love + Focus = {totalScore}! ❤️ {harmonyLevel} harmony, {combinedTime}s stamina! Couple ho toh aisi! 😍"
];

const coupleAchievements = {
    perfectHarmony: { name: "Perfect Harmony", icon: "💕", description: "Scores within 10% of each other" },
    powerCouple: { name: "Power Couple", icon: "💪", description: "Combined score over 300" },
    marathonLovers: { name: "Marathon Lovers", icon: "⏰", description: "Combined time over 3 minutes" },
    synchronizedSouls: { name: "Synchronized Souls", icon: "🎯", description: "3+ shared achievements" },
    competitiveSpirits: { name: "Competitive Spirits", icon: "⚡", description: "Score difference over 100" },
    twinFlames: { name: "Twin Flames", icon: "🔥", description: "Identical scores" }
};

// ========================================================================
// DISTRACTION SYSTEM
// ========================================================================
const distractionTypes = [
    // EXISTING HIGH URGENCY - Mobile adjusted
    { icon: '📱', urgency: 'high', points: 15, timeout: gameState.isMobile ? 1350 : 1500, name: 'phone', type: 'standard' },        
    { icon: '📧', urgency: 'high', points: 18, timeout: gameState.isMobile ? 1350 : 1500, name: 'email', type: 'standard' },        
    { icon: '☎️', urgency: 'high', points: 20, timeout: gameState.isMobile ? 1350 : 1500, name: 'call', type: 'standard' },         
    { icon: '💬', urgency: 'high', points: 16, timeout: gameState.isMobile ? 1350 : 1500, name: 'message', type: 'standard' },      
    { icon: '💼', urgency: 'high', points: 22, timeout: gameState.isMobile ? 1350 : 1500, name: 'work', type: 'standard' },         
    { icon: '🚨', urgency: 'high', points: 25, timeout: gameState.isMobile ? 1350 : 1500, name: 'emergency', type: 'standard' },
    
    // HIGH URGENCY DISTRACTIONS
    { icon: '🔥', urgency: 'high', points: 24, timeout: gameState.isMobile ? 1350 : 1500, name: 'urgent_alert', type: 'standard' },
    { icon: '⚠️', urgency: 'high', points: 21, timeout: gameState.isMobile ? 1350 : 1500, name: 'warning', type: 'standard' },
    { icon: '👥', urgency: 'high', points: 19, timeout: gameState.isMobile ? 1350 : 1500, name: 'family_call', type: 'standard' },
    
    // EXISTING MEDIUM URGENCY - Mobile adjusted
    { icon: '⏰', urgency: 'medium', points: 10, timeout: gameState.isMobile ? 1600 : 1800, name: 'alarm', type: 'standard' },       
    { icon: '🍕', urgency: 'medium', points: 12, timeout: gameState.isMobile ? 1600 : 1800, name: 'food', type: 'standard' },        
    { icon: '🎮', urgency: 'medium', points: 9, timeout: gameState.isMobile ? 1600 : 1800, name: 'game', type: 'standard' },         
    { icon: '🔔', urgency: 'medium', points: 11, timeout: gameState.isMobile ? 1600 : 1800, name: 'notification', type: 'standard' }, 
    { icon: '🛒', urgency: 'medium', points: 8, timeout: gameState.isMobile ? 1600 : 1800, name: 'shopping', type: 'standard' },     
    { icon: '🌟', urgency: 'medium', points: 13, timeout: gameState.isMobile ? 1600 : 1800, name: 'social', type: 'standard' },
    
    // MEDIUM URGENCY DISTRACTIONS
    { icon: '🚗', urgency: 'medium', points: 14, timeout: gameState.isMobile ? 1600 : 1800, name: 'car_honk', type: 'standard' },
    { icon: '🏠', urgency: 'medium', points: 12, timeout: gameState.isMobile ? 1600 : 1800, name: 'doorbell', type: 'standard' },
    { icon: '💰', urgency: 'medium', points: 15, timeout: gameState.isMobile ? 1600 : 1800, name: 'bank_alert', type: 'standard' },
    { icon: '🐕', urgency: 'medium', points: 11, timeout: gameState.isMobile ? 1600 : 1800, name: 'pet_needs', type: 'standard' },
    { icon: '📅', urgency: 'medium', points: 13, timeout: gameState.isMobile ? 1600 : 1800, name: 'calendar', type: 'standard' },
    
    // EXISTING LOW URGENCY - Keep same for both
    { icon: '📺', urgency: 'low', points: 8, timeout: 2100, name: 'tv', type: 'standard' },             
    { icon: '🎵', urgency: 'low', points: 7, timeout: 2100, name: 'music', type: 'standard' },          
    { icon: '📰', urgency: 'low', points: 6, timeout: 2100, name: 'news', type: 'standard' },           
    { icon: '🎬', urgency: 'low', points: 5, timeout: 2100, name: 'video', type: 'standard' },
    
    // LOW URGENCY DISTRACTIONS
    { icon: '☕', urgency: 'low', points: 6, timeout: 2100, name: 'coffee_break', type: 'standard' },
    { icon: '🌙', urgency: 'low', points: 5, timeout: 2100, name: 'sleepy', type: 'standard' },
    { icon: '📚', urgency: 'low', points: 7, timeout: 2100, name: 'reading', type: 'standard' },
          
    // EXISTING TROPHIES - Keep same
    { icon: '🏆', urgency: 'high', points: 50, timeout: 2500, name: 'trophy_gold', type: 'trophy' },     
    { icon: '🎯', urgency: 'medium', points: 35, timeout: 2500, name: 'trophy_target', type: 'trophy' },  
    { icon: '💎', urgency: 'high', points: 75, timeout: 2500, name: 'trophy_diamond', type: 'trophy' },  
    
    // EXISTING STICKY NOTES - Keep same
    { icon: 'URGENT!', urgency: 'medium', points: 25, timeout: 3000, name: 'sticky_urgent', type: 'sticky' },   
    { icon: 'Meeting', urgency: 'low', points: 20, timeout: 3000, name: 'sticky_meeting', type: 'sticky' },     
    { icon: 'Call Mom', urgency: 'low', points: 15, timeout: 3000, name: 'sticky_personal', type: 'sticky' }    
];

// MOBILE TIMEOUT ADJUSTMENTS 
function getMobileAdjustedTimeout(distractionType, movementType) {
    let baseTimeout = distractionType.timeout;
    
    // Apply mobile base adjustments
    if (gameState.isMobile) {
        switch (distractionType.urgency) {
            case 'high':
                baseTimeout = baseTimeout === 1500 ? 1350 : baseTimeout;
                break;
            case 'medium':
                baseTimeout = baseTimeout === 1800 ? 1600 : baseTimeout;
                break;
            // low urgency stays the same
        }
        
        // Apply movement-based adjustments (mobile only)
        switch (movementType) {
            case 'sliding':
                baseTimeout = Math.round(baseTimeout * 0.85);
                break;
            case 'bouncing':
                baseTimeout = Math.round(baseTimeout * 0.80);
                break;
            case 'orbital':
                baseTimeout = Math.round(baseTimeout * 0.75);
                break;
            case 'phantom':
                baseTimeout = Math.round(baseTimeout * 0.70);
                break;
        }
    }
    
    return baseTimeout;
}
// ========================================================================
// TIMER MANAGEMENT
// ========================================================================
const timerManager = {
    timeouts: new Set(),
    intervals: new Set(),
    
    addTimeout(id) {
        this.timeouts.add(id);
        return id;
    },
    
    addInterval(id) {
        this.intervals.add(id);
        return id;
    },
    
    clearAll() {
        console.log(`⏰ Clearing ${this.timeouts.size} timeouts and ${this.intervals.size} intervals`);
        
        this.timeouts.forEach(id => clearTimeout(id));
        this.intervals.forEach(id => clearInterval(id));

    // Clear spawn interval and reset flags
    if (this.spawnInterval) {
        clearInterval(this.spawnInterval);
        this.spawnInterval = null;
        this.spawnIntervalInitialized = false;
        this.lastSpawnAttempt = null;
        console.log('🛑 Spawn interval cleared');
    }
        
        this.timeouts.clear();
        this.intervals.clear();
    }
};

// ========================================================================
// SCREEN MANAGEMENT
// ========================================================================
function showScreen(screenId) {
    console.log(`📺 Showing screen: ${screenId}`);
    
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
        screen.style.display = 'none';
    });
    
    const screen = document.getElementById(screenId);
    if (screen) {
        screen.style.display = 'flex';
        screen.classList.add('active');
        gameState.currentScreen = screenId;
        console.log(`✅ Screen shown: ${screenId}`);
    }
}

// ========================================================================
// DYNAMIC LOADING TIP SYSTEM
// ========================================================================
function getRandomLoadingTip() {
    if (typeof loadingTips === 'undefined' || loadingTips.length === 0) {
        return "💡 Pro tip: Lasting longer starts with the right preparation... 😉"; // Fallback
    }
    const randomIndex = Math.floor(Math.random() * loadingTips.length);
    return loadingTips[randomIndex];
}

function updateLoadingTip() {
    const tipElement = document.getElementById('loadingTip');
    if (tipElement) {
        tipElement.textContent = getRandomLoadingTip();
        console.log('💡 Dynamic loading tip updated');
    }
}

// ========================================================================
// AUDIO SYSTEM WITH BACKGROUND MUSIC AND MOVEMENT SOUNDS
// ========================================================================
const audioManager = {
    audioContext: null,
    sounds: {},
    backgroundMusic: null,
    audioEnabled: true,
    isInitialized: false,
    musicPlaying: false,
    
    settings: {
        masterVolume: 1.0,
        sfxVolume: 1.0,
        musicVolume: 0.8,
        enableSFX: true,
        enableMusic: true
    },
    
    // Initialize audio system with user interaction
    async init() {
        console.log('🎵 Initializing audio system...');
        
        try {
            // Create audio context on user interaction
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Resume context if suspended (required by modern browsers)
            if (this.audioContext.state === 'suspended') {
                await this.audioContext.resume();
                console.log('🎵 Audio context resumed');
            }
            
            this.settings.enableSFX = gameState.audioEnabled;
            this.generateSounds();
            this.initBackgroundMusic();
            this.isInitialized = true;
            
            console.log('✅ Audio system ready with background music');
        } catch (error) {
            console.error('❌ Audio initialization failed:', error);
        }
    },
    
    // Audio context starts on first user interaction
    async ensureAudioContext() {
        if (!this.isInitialized) {
            await this.init();
        }
        
        if (this.audioContext && this.audioContext.state === 'suspended') {
            await this.audioContext.resume();
            console.log('🎵 Audio context resumed on interaction');
        }
    },
    
    // Initialize background music
    initBackgroundMusic() {
        try {
            this.backgroundMusic = new Audio();
            this.backgroundMusic.loop = true;
            this.backgroundMusic.volume = this.settings.musicVolume;
            
            // Procedural background music using Web Audio API
            this.createProceduralMusic();
            
            this.backgroundMusic.addEventListener('error', (e) => {
                console.warn('Background music failed to load:', e);
            });
            
            console.log('🎼 Background music initialized');
        } catch (error) {
            console.warn('Background music initialization failed:', error);
        }
    },
    
    // Create procedural ambient music
    createProceduralMusic() {
        if (!this.audioContext) return;
        
        // Create a simple ambient drone for background
        const createAmbientDrone = () => {
            const oscillator1 = this.audioContext.createOscillator();
            const oscillator2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            const filter = this.audioContext.createBiquadFilter();
            
            oscillator1.connect(filter);
            oscillator2.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            oscillator1.frequency.setValueAtTime(110, this.audioContext.currentTime); // A2
            oscillator2.frequency.setValueAtTime(165, this.audioContext.currentTime); // E3
            oscillator1.type = 'sine';
            oscillator2.type = 'sine';
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(this.settings.musicVolume * 0.3, this.audioContext.currentTime + 2);
            
            oscillator1.start();
            oscillator2.start();
            
            return { oscillator1, oscillator2, gainNode };
        };
        
        this.ambientDrone = createAmbientDrone;
        console.log('🎼 Procedural music system ready');
    },
    
   // Play background music
playBackgroundMusic() {
    if (!this.settings.enableMusic || !gameState.audioEnabled || !this.audioContext) return;
    
    if (!this.musicPlaying) {
        try {
            // Create audible ambient music (using the working test settings)
            const oscillator1 = this.audioContext.createOscillator();
            const oscillator2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            // Connect audio graph
            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            // Higher, more audible frequencies (same as working test)
            oscillator1.frequency.setValueAtTime(220, this.audioContext.currentTime); // A3
            oscillator2.frequency.setValueAtTime(330, this.audioContext.currentTime); // E4
            oscillator1.type = 'sine';
            oscillator2.type = 'triangle'; // Mix of waveforms for richer sound
            
            // Audible volume level (based on working test)
            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(this.settings.musicVolume * 0.35, this.audioContext.currentTime + 2);
            
            // Start oscillators
            oscillator1.start();
            oscillator2.start();
            
            // Store references for cleanup
            this.currentDrone = { oscillator1, oscillator2, gainNode };
            this.musicPlaying = true;
            
            console.log('🎵 Audible background music started');
            
        } catch (error) {
            console.warn('Background music failed to start:', error);
        }
    }
},

// Stop background music
stopBackgroundMusic() {
    if (this.currentDrone && this.musicPlaying) {
        try {
            this.currentDrone.oscillator1.stop();
            this.currentDrone.oscillator2.stop();
            this.musicPlaying = false;
            console.log('🎵 Background music stopped');
        } catch (error) {
            console.warn('Error stopping background music:', error);
        }
    }
},

// Generate sound effects
generateSounds() {
    console.log('🎶 Generating sounds with movement effects...');
    
    const soundDefinitions = {
        // ELIMINATION SOUNDS
        eliminate: { 
            type: 'layered',
            layers: [
                { frequency: 880, type: 'square', duration: 0.15, volume: 0.7 },
                { frequency: 1320, type: 'sine', duration: 0.1, volume: 0.4 },
                { frequency: 440, type: 'triangle', duration: 0.2, volume: 0.3 }
            ]
        },
        
        // PUNCHY COMBO SOUND
        combo: { 
            type: 'sweep',
            startFreq: 800, 
            endFreq: 1600, 
            duration: 0.25, 
            volume: 0.8,
            waveType: 'sawtooth'
        },
        
        // MODERN POP SOUND
        pop: {
            type: 'pop',
            frequency: 1000,
            duration: 0.1,
            volume: 0.9
        },
        
        // GAME SOUNDS 
        milestone: { frequency: 660, type: 'triangle', duration: 0.4, volume: 0.9 },
        miss: { frequency: 330, type: 'sawtooth', duration: 0.2, volume: 0.7 },
        danger: { frequency: 220, type: 'square', duration: 0.5, volume: 0.8 },
        gameOver: { frequency: 200, type: 'sawtooth', duration: 0.8, volume: 0.9 },
        highScore: { frequency: 1100, type: 'sine', duration: 0.6, volume: 0.9 },
        
        // Phantom and movement sounds
        phantomSpawn: { frequency: 800, type: 'sine', duration: 0.3, volume: 0.6 },
        phantomWhisper: { frequency: 600, type: 'triangle', duration: 0.2, volume: 0.4 },
        levelUp: { frequency: 880, type: 'triangle', duration: 0.5, volume: 0.8 },
        swoosh: { frequency: 440, type: 'sawtooth', duration: 0.15, volume: 0.5 }
    };
    
    this.sounds = {};
    
    Object.keys(soundDefinitions).forEach(soundName => {
        this.sounds[soundName] = () => {
            const def = soundDefinitions[soundName];
            
            // Handle different sound types properly
            if (def.type === 'layered') {
                // For layered sounds like eliminate
                this.createTrendyEliminate(def.layers[0].frequency, def.layers[0].duration, def.layers[0].volume, 0);
            } else if (def.type === 'sweep') {
                // For sweep sounds like combo  
                this.createTrendyCombo(def.startFreq, def.duration, def.volume, 0);
            } else if (def.type === 'pop') {
                // For pop sounds
                this.createTrendyEliminate(def.frequency, def.duration, def.volume, 0); // Use eliminate logic for pop
            } else {
                // For simple sounds (milestone, miss, danger, etc.)
                this.playEnhancedSound(def.frequency, def.type, def.duration, def.volume, soundName);
            }
        };
    });
    
    console.log('✅ Audio system with movement sounds ready');
},

// Sound engine with stereo and modern effects 
async playEnhancedSound(frequency, waveType, duration, baseVolume, soundName) {
    if (!this.settings.enableSFX || !gameState.audioEnabled) {
        console.log(`🔇 ${soundName} audio disabled`);
        return;
    }
    
    await this.ensureAudioContext();
    
    if (!this.audioContext) {
        console.log('❌ No audio context available');
        return;
    }
    
    // SAFE PARAMETER VALIDATION
    const safeFrequency = isFinite(frequency) && frequency > 0 ? frequency : 880;
    const safeWaveType = waveType || 'sine';
    const safeDuration = isFinite(duration) && duration > 0 ? duration : 0.2;
    const safeBaseVolume = isFinite(baseVolume) && baseVolume >= 0 ? baseVolume : 0.8;
    const safeSoundName = soundName || 'unknown';
    
    try {
        // Calculate stereo position 
        const panPosition = (Math.random() - 0.5) * 0.3; // Subtle stereo spread
        
        // Add layered sounds for certain effects
        if (safeSoundName === 'eliminate') {
            this.createTrendyEliminate(safeFrequency, safeDuration, safeBaseVolume, panPosition);
        } else if (safeSoundName === 'combo') {
            this.createTrendyCombo(safeFrequency, safeDuration, safeBaseVolume, panPosition);
        } else if (safeSoundName === 'milestone') {
            this.createTrendyMilestone(safeFrequency, safeDuration, safeBaseVolume, panPosition);
        } else {
            // Single sound with stereo
            this.createEnhancedSingle(safeFrequency, safeWaveType, safeDuration, safeBaseVolume, panPosition);
        }
        
        console.log(`🔊 ${safeSoundName}: ${safeFrequency}Hz (${safeWaveType}) at volume ${safeBaseVolume.toFixed(2)} for ${safeDuration}s (pan: ${panPosition.toFixed(2)})`);
        
    } catch (error) {
        console.error(`🔊 ${safeSoundName} audio failed:`, error);
    }
},

// HELPER FUNCTIONS (Keep existing interface, add modern sounds)
createTrendyEliminate(baseFreq, duration, baseVolume, panPosition) {
    // SAFETY: Validate all input values
    const safeFreq = isFinite(baseFreq) && baseFreq > 0 ? baseFreq : 880;
    const safeDuration = isFinite(duration) && duration > 0 ? duration : 0.2;
    const safeVolume = isFinite(baseVolume) && baseVolume >= 0 ? baseVolume : 0.8;
    const safePan = isFinite(panPosition) ? Math.max(-1, Math.min(1, panPosition)) : 0;
    
    const now = this.audioContext.currentTime;
    const volume = this.settings.masterVolume * this.settings.sfxVolume * safeVolume * 1.2;
    
    // Additional safety check for final volume
    const finalVolume = isFinite(volume) && volume > 0 ? Math.min(volume, 1.0) : 0.5;
    
    try {
        // Layer 1: Main elimination sound 
        const osc1 = this.audioContext.createOscillator();
        const gain1 = this.audioContext.createGain();
        const panner1 = this.audioContext.createStereoPanner();
        
        osc1.connect(gain1);
        gain1.connect(panner1);
        panner1.connect(this.audioContext.destination);
        
        osc1.frequency.setValueAtTime(safeFreq, now);
        osc1.frequency.exponentialRampToValueAtTime(safeFreq * 1.5, now + safeDuration * 0.3);
        osc1.type = 'square';
        
        gain1.gain.setValueAtTime(finalVolume * 0.8, now);
        gain1.gain.exponentialRampToValueAtTime(0.01, now + safeDuration);
        panner1.pan.setValueAtTime(safePan, now);
        
        // Layer 2: High frequency sparkle
        const osc2 = this.audioContext.createOscillator();
        const gain2 = this.audioContext.createGain();
        const panner2 = this.audioContext.createStereoPanner();
        
        osc2.connect(gain2);
        gain2.connect(panner2);
        panner2.connect(this.audioContext.destination);
        
        osc2.frequency.setValueAtTime(safeFreq * 2.5, now);
        osc2.type = 'sine';
        
        gain2.gain.setValueAtTime(finalVolume * 0.4, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + safeDuration * 0.6);
        panner2.pan.setValueAtTime(-safePan, now); // Opposite pan for width
        
        osc1.start(now);
        osc1.stop(now + safeDuration);
        osc2.start(now);
        osc2.stop(now + safeDuration * 0.6);
        
        console.log(`🎵 Safe trendy eliminate: freq=${safeFreq}, vol=${finalVolume.toFixed(2)}, pan=${safePan.toFixed(2)}`);
        
    } catch (error) {
        console.error('❌ createTrendyEliminate failed:', error);
    }
},

createTrendyCombo(baseFreq, duration, baseVolume, panPosition) {
    // SAFETY: Validate all input values
    const safeFreq = isFinite(baseFreq) && baseFreq > 0 ? baseFreq : 1320;
    const safeDuration = isFinite(duration) && duration > 0 ? duration : 0.3;
    const safeVolume = isFinite(baseVolume) && baseVolume >= 0 ? baseVolume : 0.8;
    const safePan = isFinite(panPosition) ? Math.max(-1, Math.min(1, panPosition)) : 0;
    
    const now = this.audioContext.currentTime;
    const volume = this.settings.masterVolume * this.settings.sfxVolume * safeVolume * 1.2;
    
    // Additional safety check for final volume
    const finalVolume = isFinite(volume) && volume > 0 ? Math.min(volume, 1.0) : 0.5;
    
    try {
        // Frequency sweep for modern combo sound
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        const panner = this.audioContext.createStereoPanner();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(this.audioContext.destination);
        
        // Modern sweep effect with safe values
        const startFreq = safeFreq * 0.8;
        const endFreq = safeFreq * 2;
        
        oscillator.frequency.setValueAtTime(startFreq, now);
        oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + safeDuration);
        oscillator.type = 'sawtooth';
        
        // Filter sweep for modern sound
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(safeFreq * 2, now);
        filter.frequency.exponentialRampToValueAtTime(safeFreq * 4, now + safeDuration);
        filter.Q.setValueAtTime(2, now);
        
        // Punchy envelope
        gainNode.gain.setValueAtTime(finalVolume, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + safeDuration);
        
        // Pan sweep for stereo effect
        panner.pan.setValueAtTime(-safePan, now);
        panner.pan.linearRampToValueAtTime(safePan, now + safeDuration);
        
        oscillator.start(now);
        oscillator.stop(now + safeDuration);
        
        console.log(`🎵 Safe trendy combo: freq=${safeFreq}, vol=${finalVolume.toFixed(2)}, pan=${safePan.toFixed(2)}`);
        
    } catch (error) {
        console.error('❌ createTrendyCombo failed:', error);
    }
},

createTrendyMilestone(baseFreq, duration, baseVolume, panPosition) {
    const now = this.audioContext.currentTime;
    const volume = this.settings.masterVolume * this.settings.sfxVolume * baseVolume * 1.2;
    
    // Bell-like achievement sound with harmonics
    for (let harmonic = 1; harmonic <= 3; harmonic++) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        const panner = this.audioContext.createStereoPanner();
        
        osc.connect(gain);
        gain.connect(panner);
        panner.connect(this.audioContext.destination);
        
        osc.frequency.setValueAtTime(baseFreq * harmonic, now);
        osc.type = harmonic === 1 ? 'triangle' : 'sine';
        
        const harmonicVolume = volume / (harmonic * 1.5);
        gain.gain.setValueAtTime(harmonicVolume, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
        
        panner.pan.setValueAtTime(panPosition * (harmonic % 2 === 0 ? -1 : 1), now);
        
        osc.start(now);
        osc.stop(now + duration);
    }
},

createEnhancedSingle(frequency, waveType, duration, baseVolume, panPosition) {
    // Version of original single sounds with stereo
    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    const filter = this.audioContext.createBiquadFilter();
    const panner = this.audioContext.createStereoPanner();
    
    oscillator.connect(filter);
    filter.connect(gainNode);
    gainNode.connect(panner);
    panner.connect(this.audioContext.destination);
    
    // Oscillator setup
    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
    oscillator.type = waveType;
    
    // Filter for richer sound
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(frequency * 3, this.audioContext.currentTime);
    filter.Q.setValueAtTime(1, this.audioContext.currentTime);
    
    // Calculate volume
    const volume = this.settings.masterVolume * this.settings.sfxVolume * baseVolume * 1.2;
    
    // Gain envelope
    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01);
    gainNode.gain.linearRampToValueAtTime(volume * 0.8, this.audioContext.currentTime + duration * 0.6);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
    
    // Stereo positioning
    panner.pan.setValueAtTime(panPosition, this.audioContext.currentTime);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + duration);
},

// Play sound with proper error handling
async play(soundName, context = 'normal') {
    if (!this.settings.enableSFX || !gameState.audioEnabled) return;
    
    const sound = this.sounds[soundName];
    if (sound) {
        try {
            await sound();
            console.log(`🔊 Playing: ${soundName} (${context})`);
        } catch (error) {
            console.log('🔇 Audio play failed:', error);
        }
    } else {
        console.log(`🔇 Sound not found: ${soundName}`);
    }
},

// Play sound with proper error handling 
playSound(soundName, volume = 1.0) {
    console.log(`🔊 playSound called: ${soundName} at volume ${volume}`);

    // Use the existing play method which has proper error handling
    if (this.play) {
        return this.play(soundName, 'playSound-call');
    } else {
        console.log(`🔇 No play method available for ${soundName}`);
    }
}, 

// Adjust music volume
adjustMusicVolume(volume) {
    this.settings.musicVolume = Math.max(0, Math.min(1, volume));
    if (this.currentDrone && this.currentDrone.gainNode) {
        this.currentDrone.gainNode.gain.setValueAtTime(
            this.settings.musicVolume * 0.3, 
            this.audioContext.currentTime
        );
    }
    console.log(`🎵 Music volume adjusted to ${this.settings.musicVolume}`);
},

// Toggle audio system
toggle() {
    this.settings.enableSFX = !this.settings.enableSFX;
    gameState.audioEnabled = this.settings.enableSFX;
    
    if (!this.settings.enableSFX) {
        this.stopBackgroundMusic();
    } else if (this.settings.enableMusic) {
        this.playBackgroundMusic();
    }
    
    console.log(`🎵 Audio ${this.settings.enableSFX ? 'enabled' : 'disabled'}`);
    return this.settings.enableSFX;
},

// Toggle background music specifically
toggleMusic() {
    this.settings.enableMusic = !this.settings.enableMusic;
    
    if (this.settings.enableMusic && this.settings.enableSFX && gameState.audioEnabled) {
        this.playBackgroundMusic();
    } else {
        this.stopBackgroundMusic();
    }
    
    console.log(`🎼 Background music ${this.settings.enableMusic ? 'enabled' : 'disabled'}`);
    return this.settings.enableMusic;
}
};
// ========================================================================
// PARTICLE SYSTEM WITH PROPER INITIALIZATION
// ========================================================================
const particleSystem = {
    particles: [],
    canvas: null,
    ctx: null,
    animationId: null,
    isInitialized: false,
    
    init() {
        console.log('✨ Initializing particle system...');
        this.createCanvas();
        this.startAnimation();
        this.isInitialized = true;
        console.log('✅ Particle system ready');
    },
    
    createCanvas() {
        // Remove existing canvas if any
        const existing = document.getElementById('particleCanvas');
        if (existing) existing.remove();
        // Particle Canvas Positioning
        this.canvas = document.createElement('canvas');
        this.canvas.id = 'particleCanvas';
        this.canvas.style.position = 'fixed';
        this.canvas.style.top = '0px';
        this.canvas.style.left = '0px';
        this.canvas.style.width = '100vw';
        this.canvas.style.height = '100vh';
        this.canvas.style.pointerEvents = 'none';
        this.canvas.style.zIndex = '15'; // Above Three.js (10), below distractions (100)
        document.body.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        window.addEventListener('resize', () => this.resize());
        
        console.log('✅ Particle canvas created with z-index 15');
    },
    
    resize() {
        if (this.canvas) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }
    },
    
    // Ensure system is initialized before creating particles
    ensureInitialized() {
        if (!this.isInitialized) {
            this.init();
        }
    },
    
    createEliminationBurst(x, y, color = '#FFD700', intensity = 1) {
        this.ensureInitialized();
        
        const particleCount = Math.floor(12 * intensity); // INCREASED from 8
        
        for (let i = 0; i < particleCount; i++) {
            this.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 12 * intensity, // INCREASED velocity
                vy: (Math.random() - 0.5) * 12 * intensity,
                life: 1.0,
                decay: 0.015 + Math.random() * 0.01, // SLOWER decay
                size: 4 + Math.random() * 6, // LARGER particles
                color: color,
                type: 'elimination'
            });
        }
        
        console.log(`✨Created elimination burst at (${x}, ${y}) with ${particleCount} particles`);
    },
    
    createComboBurst(x, y, comboLevel) {
        this.ensureInitialized();
        
        const colors = ['#ff6b6b', '#ffa500', '#ffff00', '#00ff00', '#00ffff'];
        const color = colors[Math.min(comboLevel - 1, colors.length - 1)];
        const intensity = Math.min(comboLevel * 0.7, 4); // INCREASED intensity
        
        this.createEliminationBurst(x, y, color, intensity);
        
        // Add special combo ring effect
        this.particles.push({
            x: x,
            y: y,
            radius: 5,
            maxRadius: 80 + comboLevel * 15, // LARGER rings
            life: 1.0,
            decay: 0.025, // SLOWER decay
            color: color,
            type: 'ring'
        });
        
        console.log(`✨Created combo burst level ${comboLevel}`);
    },
    
    // particleSystem object
  createBurst(x, y, color, count = 12) {
        this.ensureInitialized();
        
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            const speed = 2 + Math.random() * 4;
            
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1,
                decay: 0.02 + Math.random() * 0.02,
                size: 3 + Math.random() * 4,
                color: color,
                type: 'burst'
            });
        }
        
        console.log(`💥 Created particle burst at (${x}, ${y}) with ${count} particles`);
    },

    createMilestoneCelebration() {
        this.ensureInitialized();
        
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        for (let burst = 0; burst < 8; burst++) { // INCREASED from 5
            setTimeout(() => {
                const x = centerX + (Math.random() - 0.5) * 300; // WIDER spread
                const y = centerY + (Math.random() - 0.5) * 300;
                this.createEliminationBurst(x, y, '#FFD700', 3); // HIGHER intensity
            }, burst * 80); // FASTER bursts
        }
        
        console.log('🎉 Milestone celebration particles created');
    },
    
    update() {
    if (!this.ctx || !this.canvas) return;
    
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Update particles
    for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];
        
        if (particle.type === 'elimination') {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += 0.3; // INCREASED gravity
            particle.vx *= 0.97; // LESS air resistance
            
            particle.life -= particle.decay;
            
            // BRIGHTER rendering
            this.ctx.save();
            this.ctx.globalAlpha = particle.life;
            this.ctx.fillStyle = particle.color;
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = 10; // ADD glow effect
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
            
        } else if (particle.type === 'ring') {
            particle.radius += (particle.maxRadius - particle.radius) * 0.15; // FASTER expansion
            particle.life -= particle.decay;
            
            // BRIGHTER ring rendering
            this.ctx.save();
            this.ctx.globalAlpha = particle.life;
            this.ctx.strokeStyle = particle.color;
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = 15; // ADD glow
            this.ctx.lineWidth = 4; // THICKER lines
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
            this.ctx.stroke();
            this.ctx.restore();
            
        } else if (particle.type === 'burst') {
            // ✨ NEW: Handle 'burst' type particles
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += 0.3; // gravity
            particle.vx *= 0.97; // air resistance
            
            particle.life -= particle.decay;
            
            // Render burst particle
            this.ctx.save();
            this.ctx.globalAlpha = particle.life;
            this.ctx.fillStyle = particle.color;
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = 10;
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        }
        
        if (particle.life <= 0) {
            this.particles.splice(i, 1);
        }
    }
},
    
    startAnimation() {
        const animate = () => {
            this.update();
            this.animationId = requestAnimationFrame(animate);
        };
        animate();
        console.log('✅ Particle animation started');
    },
    
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        if (this.canvas) {
            this.canvas.remove();
        }
        this.particles = [];
        this.isInitialized = false;
    }
};

// ========================================================================
// PHASE 3C: SCREEN SHAKE SYSTEM - DRAMATIC IMPACT FEEDBACK
// ========================================================================
const screenShake = {
    isShaking: false,
    currentShakeId: null,
    currentPriority: 0,
    shakeQueue: [],
    
    init() {
        console.log('🔳 Screen shake system initialized with queue');
        this.isShaking = false;
        this.currentShakeId = 0;
        this.currentPriority = 0;
        this.shakeQueue = [];
    },

    shake(intensity = 1, duration = 300, type = 'normal', priority = 1) {
        const shakeRequest = { intensity, duration, type, priority, timestamp: Date.now() };
        
        if (this.isShaking) {
            if (priority > this.currentPriority) {
                console.log(`🔳 Higher priority ${type} shake interrupting`);
                this.stop();
                this.executeShake(shakeRequest);
            } else {
                this.shakeQueue.push(shakeRequest);
                this.shakeQueue.sort((a, b) => b.priority - a.priority);
                console.log(`🔳 Queued ${type} shake - ${this.shakeQueue.length} in queue`);
            }
        } else {
            this.executeShake(shakeRequest);
        }
    },
    
    executeShake(shakeRequest) {
        const { intensity, duration, type, priority } = shakeRequest;
        
        this.isShaking = true;
        this.currentPriority = priority;
        const gameScreen = document.getElementById('gameScreen');
        
        if (!gameScreen) {
            this.processQueue();
            return;
        }
        
        const originalTransform = gameScreen.style.transform || '';
        const shakeAmount = intensity * 6;
        const startTime = Date.now();
        
        console.log(`🔳 Executing ${type} shake: intensity ${intensity}, priority ${priority}`);
        
        const shakeInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / duration;
            
            if (progress >= 1) {
                gameScreen.style.transform = originalTransform;
                clearInterval(shakeInterval);
                this.isShaking = false;
                this.currentPriority = 0;
                this.currentShakeId = null;
                this.processQueue();
                console.log('🔳 Screen shake completed');
                return;
            }
            
            const currentIntensity = shakeAmount * (1 - progress);
            const x = (Math.random() - 0.5) * currentIntensity;
            const y = (Math.random() - 0.5) * currentIntensity;
            
            gameScreen.style.transform = `${originalTransform} translate(${x}px, ${y}px)`;
        }, 16);
        
        this.currentShakeId = shakeInterval;
    },
    
    processQueue() {
        if (this.shakeQueue.length > 0 && !this.isShaking) {
            const nextShake = this.shakeQueue.shift();
            this.executeShake(nextShake);
        }
    },
    
    // Methods with priorities
    subtle() { this.shake(0.7, 250, 'subtle', 1); },
    moderate() { this.shake(1.2, 350, 'moderate', 1); },
    intense() { this.shake(2.0, 500, 'intense', 2); },
    elimination() { this.shake(0.8, 200, 'elimination', 1); },
    combo(comboLevel) { 
        const intensity = Math.min(0.6 + (comboLevel * 0.3), 2.5);
        const duration = Math.min(150 + (comboLevel * 50), 400);
        this.shake(intensity, duration, 'combo', 2); 
    },
    danger() { this.shake(1.8, 600, 'danger', 3); },
    milestone() { this.shake(1.5, 800, 'milestone', 4); },
    gameOver() { this.shake(2.5, 1000, 'gameOver', 5); },
    
    stop() {
        if (this.currentShakeId) {
            clearInterval(this.currentShakeId);
            this.currentShakeId = null;
        }
        this.isShaking = false;
        this.currentPriority = 0;
        
        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen) {
            gameScreen.style.transform = '';
        }
    }
};

console.log("✅ screenShake.init method added");

function createDistraction(distractionType) {
    const distraction = document.createElement('div');
    distraction.dataset.type = distractionType.name;
    distraction.dataset.points = distractionType.points;
    distraction.dataset.spawnTime = Date.now();
    distraction.onclick = () => eliminateDistraction(distraction, distractionType);
    
    if (distractionType.type === 'sticky') {
        // Sticky note: different structure
        distraction.className = 'distraction sticky-note';
        
        const content = document.createElement('div');
        content.textContent = distractionType.icon;
        distraction.appendChild(content);
        
    } else {
        // Standard/Trophy: with priority rings
        distraction.className = `distraction distraction-${distractionType.urgency}`;
        
        // Add priority ring
        const ring = document.createElement('div');
        ring.className = 'priority-ring';
        if (distractionType.urgency === 'high') {
            ring.classList.add('critical');
        } else if (distractionType.urgency === 'medium') {
            ring.classList.add('warning');
        } else if (distractionType.urgency === 'low') {
            ring.classList.add('safe');
        }
        distraction.appendChild(ring);
        
        // Create icon
        const icon = document.createElement('div');
        icon.className = `distraction-icon urgency-${distractionType.urgency}`;
        
        if (distractionType.type === 'trophy') {
            icon.classList.add('trophy');
            
            // Add bonus badge
            const bonus = document.createElement('div');
            bonus.className = 'trophy-bonus';
            bonus.textContent = `+${distractionType.points}`;
            distraction.appendChild(bonus); 
        }
        
        icon.innerHTML = distractionType.icon;
        distraction.appendChild(icon);
    }
    
    return distraction;
}

// ========================================================================
// DYNAMIC DISTRACTION MOVEMENT SYSTEM
// ========================================================================

const distractionMovement = {
    // Device detection for performance optimization
    isMobile: false, // Set in init()
    maxMovingDistractions: 25, // Will be adjusted based on device
    currentMovingCount: 0,
    
    init() {
    // Sync with gameState mobile detection
    this.isMobile = gameState.isMobile;
    // Adjust limits based on device capability
    this.maxMovingDistractions = this.isMobile ? 16 : 25;
        console.log(`📱 Movement system initialized for ${this.isMobile ? 'mobile' : 'desktop'} (max moving: ${this.maxMovingDistractions})`);
    },
    
    // Movement type distribution (smart spawn logic)
    getMovementType() {
    // Don't create moving distractions if at limit
    if (this.currentMovingCount >= this.maxMovingDistractions) {
        return 'static';
    }
    
    const rand = Math.random() * 100;
    
    // Optimized distribution: 65% moving vs 35% static
    if (rand < 35) return 'static';        // 35%
    if (rand < 60) return 'bouncing';      // 25% 
    if (rand < 85) return 'sliding';       // 25% 
    if (rand < 95) return 'orbital';       // 10% - elliptical movement
    return 'phantom';                       // 5% - teleporting effects
   },
    
    // Speed multipliers for different movement types
    getSpeedMultiplier(movementType) {
    const speeds = {
        static: 1.0,
        sliding: 1.5,    // Up from 1.3
        bouncing: 1.8,   // Up from 1.5  
        orbital: 2.0,    // Up from 1.7
        phantom: 2.2     // Up from 1.8-2.5, now consistent
    };
    return speeds[movementType] || 1.0;
    },
    
    // Initialize movement data for a distraction
initializeMovement(distraction, movementType) {
    if (movementType !== 'static') {
        this.currentMovingCount++;
    }
    
    distraction.movementType = movementType;
    distraction.speedMultiplier = this.getSpeedMultiplier(movementType);
    
    const rect = distraction.getBoundingClientRect();
    
    switch (movementType) {
    case 'sliding':
           distraction.movementData = {
              direction: Math.random() > 0.5 ? 1 : -1, // Left or right
              axis: 'x', // Force horizontal for better visibility
              speed: 3 * distraction.speedMultiplier   // Base speed
       };
       break;
            
        case 'bouncing':
            distraction.movementData = {
                velocityX: (Math.random() - 0.5) * 4 * distraction.speedMultiplier,
                velocityY: (Math.random() - 0.5) * 4 * distraction.speedMultiplier,
                speed: 3 * distraction.speedMultiplier
            };
            break;
            
        case 'orbital':
            distraction.movementData = {
                centerX: rect.left + rect.width / 2,
                centerY: rect.top + rect.height / 2,
                radiusX: 50 + Math.random() * 30, // Elliptical
                radiusY: 30 + Math.random() * 20,
                angle: Math.random() * Math.PI * 2,
                angularSpeed: 0.05 * distraction.speedMultiplier
            };
            break;
            
        case 'phantom':
           distraction.movementData = {
                opacity: 0.7, // Start more visible
                fadeDirection: 1,
                fadeSpeed: 0.015, // Slower fade for better visibility
                teleportTimer: 0,
                teleportInterval: 1200, // Longer between teleports
                isVisible: true
           };
           distraction.style.opacity = '0.7';
          distraction.style.boxShadow = '0 0 20px rgba(255, 0, 255, 0.8)'; // Magenta glow
    
         // Play phantom spawn sound
            if (typeof audioManager !== 'undefined' && audioManager.play) {
            audioManager.play('phantomSpawn', 'spawn');
           }
           break;
    
    console.log(`🎮 Initialized ${movementType} movement (speed: ${distraction.speedMultiplier.toFixed(1)}x)`);
  }
},

// MOBILE OPTIMIZATION FUNCTIONS:
updateMovements() {
    const distractions = document.querySelectorAll('.distraction');
    
    distractions.forEach(distraction => {
        if (!distraction.movementType || distraction.movementType === 'static') return;
        
        this.updateDistraction(distraction);
    });
},

updateDistraction(distraction) {
    const rect = distraction.getBoundingClientRect();
    const gameScreen = document.getElementById('gameScreen');
    const screenRect = gameScreen.getBoundingClientRect();
    
    switch (distraction.movementType) {
        case 'sliding':
            this.updateSliding(distraction, rect, screenRect);
            break;
        case 'bouncing':
            this.updateBouncing(distraction, rect, screenRect);
            break;
        case 'orbital':
            this.updateOrbital(distraction, rect, screenRect);
            break;
        case 'phantom':
            this.updatePhantom(distraction, rect, screenRect);
            break;
    }
},

updateSliding(distraction, rect, screenRect) {
    const data = distraction.movementData;
    
    if (data.axis === 'x') {
        const newX = rect.left + (data.direction * data.speed);
        
        if (newX <= screenRect.left || newX + rect.width >= screenRect.right) {
            data.direction *= -1;
            audioManager.playSound('bounce');
        }
        
        distraction.style.left = (newX - screenRect.left) + 'px';
    } else {
        const newY = rect.top + (data.direction * data.speed);
        
        if (newY <= screenRect.top || newY + rect.height >= screenRect.bottom) {
            data.direction *= -1;
            audioManager.playSound('bounce');
        }
        
        distraction.style.top = (newY - screenRect.top) + 'px';
    }
},

updateBouncing(distraction, rect, screenRect) {
    const data = distraction.movementData;
    
    const newX = rect.left + data.velocityX;
    const newY = rect.top + data.velocityY;
    
    if (newX <= screenRect.left || newX + rect.width >= screenRect.right) {
        data.velocityX *= -1;
        audioManager.playSound('bounce');
    }
    
    if (newY <= screenRect.top || newY + rect.height >= screenRect.bottom) {
        data.velocityY *= -1;
        audioManager.playSound('bounce');
    }
    
    distraction.style.left = Math.max(0, Math.min(newX - screenRect.left, screenRect.width - rect.width)) + 'px';
    distraction.style.top = Math.max(0, Math.min(newY - screenRect.top, screenRect.height - rect.height)) + 'px';
},

updateOrbital(distraction, rect, screenRect) {
    const data = distraction.movementData;
    
    data.angle += data.angularSpeed;
    
    let newX = data.centerX + Math.cos(data.angle) * data.radiusX;
    let newY = data.centerY + Math.sin(data.angle) * data.radiusY;
    
    // Wrap around screen edges
    if (newX < screenRect.left) newX = screenRect.right - rect.width;
    if (newX + rect.width > screenRect.right) newX = screenRect.left;
    if (newY < screenRect.top) newY = screenRect.bottom - rect.height;
    if (newY + rect.height > screenRect.bottom) newY = screenRect.top;
    
    distraction.style.left = (newX - screenRect.left) + 'px';
    distraction.style.top = (newY - screenRect.top) + 'px';
},

updatePhantom(distraction, rect, screenRect) {
    const data = distraction.movementData;
    
    // Update opacity (fade in/out)
    data.opacity += data.fadeDirection * data.fadeSpeed;
    
    if (data.opacity >= 1.0) {
        data.opacity = 1.0;
        data.fadeDirection = -1;
    } else if (data.opacity <= 0.3) {
        data.opacity = 0.3;
        data.fadeDirection = 1;
    }
    
    distraction.style.opacity = data.opacity;
    
    // Teleport timer
    data.teleportTimer += 16; // Assuming 60fps
    
    if (data.teleportTimer >= data.teleportInterval) {
        // Teleport to new position
        const newX = Math.random() * (screenRect.width - rect.width);
        const newY = Math.random() * (screenRect.height - rect.height);
        
        distraction.style.left = newX + 'px';
        distraction.style.top = newY + 'px';
        
        data.teleportTimer = 0;
        data.teleportInterval = 800 + Math.random() * 400;
        
        audioManager.playSound('teleport');
    }
},

onDistractionRemoved(distraction) {
    if (distraction.movementType && distraction.movementType !== 'static') {
        this.currentMovingCount--;
        
        if (distraction.movementType === 'phantom') {
            audioManager.playSound('phantomWhisper');
        }
    }
}
};
function getRandomDistractionType() {
    const random = Math.random();
    
    // 5% chance for rare trophies
    if (random < 0.05) {
        const trophyTypes = distractionTypes.filter(type => type.type === 'trophy');
        if (trophyTypes.length > 0) {
            const selectedTrophy = trophyTypes[Math.floor(Math.random() * trophyTypes.length)];
            console.log(`✨ RARE TROPHY: ${selectedTrophy.name} (+${selectedTrophy.points} pts)`);
            return selectedTrophy;
        }
    }
    
    // 10% chance for sticky notes
    if (random < 0.15) {
        const stickyTypes = distractionTypes.filter(type => type.type === 'sticky');
        if (stickyTypes.length > 0) {
            return stickyTypes[Math.floor(Math.random() * stickyTypes.length)];
        }
    }
    
    // 85% chance for standard distractions (your existing behavior)
    const standardTypes = distractionTypes.filter(type => type.type === 'standard');
    return standardTypes[Math.floor(Math.random() * standardTypes.length)];
}
// ========================================================================
// PHASE 3C: ANIMATED BACKGROUND SYSTEM - SUBTLE MOVING STARS
// ========================================================================
const backgroundEffects = {
    canvas: null,
    ctx: null,
    animationId: null,
    stars: [],
    isRunning: false,
    
    init() {
        console.log('🌟 Initializing animated background...');
        this.createBackgroundCanvas();
        this.generateStars();
        this.startAnimation();
    },
    
    createBackgroundCanvas() {
    // Remove existing canvas if it exists
    const existingCanvas = document.getElementById('backgroundCanvas');
    if (existingCanvas) {
        existingCanvas.remove();
    }
    
    //Background Canvas Positioning
    this.canvas = document.createElement('canvas');
    this.canvas.id = 'backgroundCanvas';
    this.canvas.style.position = 'fixed';
    this.canvas.style.top = '0px';
    this.canvas.style.left = '0px';
    this.canvas.style.width = '100vw';
    this.canvas.style.height = '100vh';
    this.canvas.style.pointerEvents = 'none';
    this.canvas.style.zIndex = '-1'; // Behind everything
    this.canvas.style.opacity = '0.9';
    this.canvas.style.display = 'block';

   // Append to body for full viewport coverage
    document.body.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    this.resize();

    console.log('🌟 Background canvas created and positioned with full viewport coverage');
},
    
    resize() {
    if (!this.canvas) return;
    
    // Update canvas dimensions
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
    
    // Canvas styling remains correct after resize
    this.canvas.style.width = '100vw';
    this.canvas.style.height = '100vh';
    
    // Regenerate stars for new dimensions
    if (this.stars.length > 0) {
        this.generateStars();
    }
    
    console.log(`🌟 Background canvas resized to ${this.canvas.width}x${this.canvas.height}`);
},
    generateStars() {
        this.stars = [];
        const starCount = Math.floor((window.innerWidth * window.innerHeight) / 4500); // Density based on screen size 
        
        // Generate regular stars with visibility
for (let i = 0; i < starCount; i++) {
    this.stars.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        size: Math.random() * 2 + 1.5, // 1.5 to 3.5 pixels (was 0.5-2.5)
        speed: (Math.random() * 0.5 + 0.1) * 1.4, // 1.4x faster movement
        opacity: (Math.random() * 0.8 + 0.2) * 1.3, // 1.3x brighter, capped at 1.0
        twinkle: Math.random() * 0.02 + 0.005,
        twinkleOffset: Math.random() * Math.PI * 2
    });
}

// Add 8 bright "guide stars" for better visibility
for (let i = 0; i < 8; i++) {
    this.stars.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        size: 2.5, // Larger guide stars
        speed: 0.4, // Faster movement
        opacity: 1.0, // Full opacity
        twinkle: 0.015,
        twinkleOffset: Math.random() * Math.PI * 2
    });
}
        
        console.log(`🌟 Generated ${this.stars.length} stars`);
    },
    
    startAnimation() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.animate();
        console.log('🌟 Star animation started');
    },
    
    animate() {
        if (!this.isRunning || !this.ctx) return;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Update and draw stars
        const time = Date.now() * 0.001; // Convert to seconds
        
        this.stars.forEach(star => {
            // Move star slowly to the left
            star.x -= star.speed;
            
            // Wrap around when star goes off screen
            if (star.x < -10) {
                star.x = window.innerWidth + 10;
                star.y = Math.random() * window.innerHeight;
            }
            
            // Calculate twinkle effect
            const twinkleIntensity = Math.sin(time * star.twinkle + star.twinkleOffset) * 0.3 + 0.7;
            const currentOpacity = star.opacity * twinkleIntensity;
            
            // Draw star with visibility and glow
            this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(currentOpacity, 1.0)})`;
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            this.ctx.fill();

           // Add subtle glow for better visibility (only for larger stars)
          if (star.size > 2) {
            this.ctx.save();
            this.ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            this.ctx.shadowBlur = star.size * 1.5;
            this.ctx.globalAlpha = currentOpacity * 0.3;
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.size * 0.5, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.restore();
        }
         // Subtle corner visibility indicators (draw once per animation frame)
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            this.ctx.beginPath();
            this.ctx.arc(20, 20, 3, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(this.canvas.width - 20, 20, 3, 0, Math.PI * 2);
            this.ctx.fill();
        });
        
        // Continue animation
        this.animationId = requestAnimationFrame(() => this.animate());
    },
    
    stop() {
        this.isRunning = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        console.log('🌟 Star animation stopped');
    },
    
    destroy() {
        this.stop();
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        this.canvas = null;
        this.ctx = null;
        this.stars = [];
        console.log('🌟 Background effects destroyed');
    },
    
    // Speed up stars during combos for dynamic effect
    boostSpeed(multiplier = 2) {
        this.stars.forEach(star => {
            star.speed = Math.min(star.speed * multiplier, 3); // Cap at 3 pixels per frame
        });
        console.log(`🌟 Star speed boosted by ${multiplier}x`);
        
        // Reset speed after 2 seconds
        setTimeout(() => {
            this.stars.forEach(star => {
                star.speed = star.speed / multiplier;
            });
            console.log('🌟 Star speed returned to normal');
        }, 2000);
    }
};

// Handle window resize for background canvas
window.addEventListener('resize', () => {
    if (backgroundEffects.canvas) {
        backgroundEffects.resize();
    }
});

// ========================================================================
// PHASE 3C: ACHIEVEMENT SYSTEM - 8 ACHIEVEMENTS
// ========================================================================
const achievementSystem = {
    achievements: {
        firstBlood: {
            id: 'firstBlood',
            name: 'First Blood',
            description: 'Eliminate your first distraction',
            icon: '🎯',
            unlocked: false,
            progress: 0,
            maxProgress: 1
        },
        comboMaster: {
            id: 'comboMaster',
            name: 'Combo Master',
            description: 'Achieve a 5x combo streak',
            icon: '🔥',
            unlocked: false,
            progress: 0,
            maxProgress: 5
        },
        speedDemon: {
            id: 'speedDemon',
            name: 'Speed Demon',
            description: 'Eliminate 10 distractions in 15 seconds',
            icon: '⚡',
            unlocked: false,
            progress: 0,
            maxProgress: 10,
            timeWindow: 15000, // 15 seconds
            timestamps: []
        },
        survivor: {
            id: 'survivor',
            name: 'Survivor',
            description: 'Play for 60 seconds straight',
            icon: '🛡️',
            unlocked: false,
            progress: 0,
            maxProgress: 60
        },
        ironWill: {
            id: 'ironWill',
            name: 'Iron Will',
            description: 'Reach level 5 without losing a heart',
            icon: '💪',
            unlocked: false,
            progress: 0,
            maxProgress: 5
        },
        perfectAccuracy: {
            id: 'perfectAccuracy',
            name: 'Perfect Focus',
            description: 'Maintain 100% accuracy for 30 seconds',
            icon: '🎯',
            unlocked: false,
            progress: 0,
            maxProgress: 30,
            startTime: null
        },
        enduranceChampion: {
            id: 'enduranceChampion',
            name: 'Endurance Champion',
            description: 'Survive for 2 minutes',
            icon: '👑',
            unlocked: false,
            progress: 0,
            maxProgress: 120
        },
        focusMaster: {
            id: 'focusMaster',
            name: 'Focus Master',
            description: 'Achieve a score of 500 points',
            icon: '🧠',
            unlocked: false,
            progress: 0,
            maxProgress: 500
        }
    },
    
    init() {
        console.log('🏆 Initializing achievement system...');
        this.loadProgress();
        this.createGalleryPanel();
        this.updateGalleryDisplay();
    },
    
    createGalleryPanel() {
        // Remove existing panel if it exists
        const existingPanel = document.getElementById('achievementGallery');
        if (existingPanel) {
            existingPanel.remove();
        }
        
        const panel = document.createElement('div');
        panel.id = 'achievementGallery';
        panel.innerHTML = `
            <div class="achievement-header">
                <h3>🏆 Achievements</h3>
                <div class="achievement-count">
                    <span id="unlockedCount">0</span>/<span id="totalCount">8</span>
                </div>
            </div>
            <div class="achievement-list" id="achievementList">
                <!-- Achievements will be populated here -->
            </div>
        `;
        
        // Append to game screen instead of body
         const gameScreen = document.getElementById('gameScreen');
         if (gameScreen) {
         gameScreen.appendChild(panel);
        } else {
         document.body.appendChild(panel); // Fallback
        }
        console.log('🏆 Achievement gallery panel created');
        },
    
    updateGalleryDisplay() {
        const listElement = document.getElementById('achievementList');
        const unlockedCountElement = document.getElementById('unlockedCount');
        
        if (!listElement) return;
        
        let unlockedCount = 0;
        let html = '';
        
        Object.values(this.achievements).forEach(achievement => {
            if (achievement.unlocked) unlockedCount++;
            
            const progressPercent = Math.min((achievement.progress / achievement.maxProgress) * 100, 100);
            const isUnlocked = achievement.unlocked;
            
            html += `
                <div class="achievement-item ${isUnlocked ? 'unlocked' : 'locked'}">
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-info">
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-description">${achievement.description}</div>
                        <div class="achievement-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progressPercent}%"></div>
                            </div>
                            <span class="progress-text">${achievement.progress}/${achievement.maxProgress}</span>
                        </div>
                    </div>
                </div>
            `;
        });
        
        listElement.innerHTML = html;
        if (unlockedCountElement) {
            unlockedCountElement.textContent = unlockedCount;
        }
    },
    
    checkAchievements() {
        const currentTime = Date.now();
        const gameTime = (currentTime - gameState.gameStartTime) / 1000;
        
        // First Blood
        if (!this.achievements.firstBlood.unlocked && gameState.eliminatedDistractions >= 1) {
            this.unlockAchievement('firstBlood');
        }
        
        // Combo Master
        if (!this.achievements.comboMaster.unlocked && gameState.combo >= 5) {
            this.achievements.comboMaster.progress = Math.max(this.achievements.comboMaster.progress, gameState.combo);
            this.unlockAchievement('comboMaster');
        }
        
        // Speed Demon - 10 eliminations in 15 seconds
        if (!this.achievements.speedDemon.unlocked) {
            const achievement = this.achievements.speedDemon;
            achievement.timestamps.push(currentTime);
            
            // Remove timestamps older than 15 seconds
            achievement.timestamps = achievement.timestamps.filter(timestamp => 
                currentTime - timestamp <= achievement.timeWindow
            );
            
            achievement.progress = achievement.timestamps.length;
            if (achievement.progress >= achievement.maxProgress) {
                this.unlockAchievement('speedDemon');
            }
        }
        
        // Survivor - 60 seconds
        if (!this.achievements.survivor.unlocked) {
            this.achievements.survivor.progress = Math.floor(gameTime);
            if (gameTime >= 60) {
                this.unlockAchievement('survivor');
            }
        }
        
        // Iron Will - Level 5 without losing health
        if (!this.achievements.ironWill.unlocked && gameState.lives === 3) {
            this.achievements.ironWill.progress = gameState.level;
            if (gameState.level >= 5) {
                this.unlockAchievement('ironWill');
            }
        } else if (gameState.lives < 3) {
            // Reset progress if health is lost
            this.achievements.ironWill.progress = 0;
        }
        
        // Perfect Accuracy - 100% for 30 seconds
        if (!this.achievements.perfectAccuracy.unlocked) {
            const accuracy = gameState.totalDistractions > 0 ? 
                (gameState.eliminatedDistractions / gameState.totalDistractions) * 100 : 100;
            
            if (accuracy === 100 && gameState.totalDistractions > 0) {
                if (!this.achievements.perfectAccuracy.startTime) {
                    this.achievements.perfectAccuracy.startTime = currentTime;
                }
                const perfectTime = (currentTime - this.achievements.perfectAccuracy.startTime) / 1000;
                this.achievements.perfectAccuracy.progress = Math.floor(perfectTime);
                
                if (perfectTime >= 30) {
                    this.unlockAchievement('perfectAccuracy');
                }
            } else {
                this.achievements.perfectAccuracy.startTime = null;
                this.achievements.perfectAccuracy.progress = 0;
            }
        }
        
        // Endurance Champion - 2 minutes
        if (!this.achievements.enduranceChampion.unlocked) {
            this.achievements.enduranceChampion.progress = Math.floor(gameTime);
            if (gameTime >= 120) {
                this.unlockAchievement('enduranceChampion');
            }
        }
        
        // Focus Master - 500 points
        if (!this.achievements.focusMaster.unlocked) {
            this.achievements.focusMaster.progress = gameState.score;
            if (gameState.score >= 500) {
                this.unlockAchievement('focusMaster');
            }
        }
        
        this.updateGalleryDisplay();
    },
    
    unlockAchievement(achievementId) {
    const achievement = this.achievements[achievementId];
    if (achievement.unlocked) return;
    
    achievement.unlocked = true;
    achievement.progress = achievement.maxProgress;
    
    console.log(`🏆 ACHIEVEMENT UNLOCKED: ${achievement.name}!`);
    
    // Use existing game message system instead of separate notification
    showGameplayMessage(
        `🏆 Achievement Unlocked!`,
        `${achievement.icon} ${achievement.name}`
    );
    
    // Keep the visual effects
    screenShake.milestone();
    particleSystem.createMilestoneCelebration();
    
    // Audio feedback
    audioManager.play('milestone', 'celebration');
    
    this.saveProgress();
},
    
    
    saveProgress() {
        try {
            const saveData = {};
            Object.keys(this.achievements).forEach(key => {
                const achievement = this.achievements[key];
                saveData[key] = {
                    unlocked: achievement.unlocked,
                    progress: achievement.progress
                };
            });
            localStorage.setItem('endlessEmbrace_achievements', JSON.stringify(saveData));
            console.log('🏆 Achievement progress saved');
        } catch (error) {
            console.log('⚠️ Could not save achievement progress:', error);
        }
    },
    
    loadProgress() {
        try {
            const saveData = localStorage.getItem('endlessEmbrace_achievements');
            if (saveData) {
                const parsed = JSON.parse(saveData);
                Object.keys(parsed).forEach(key => {
                    if (this.achievements[key]) {
                        this.achievements[key].unlocked = parsed[key].unlocked;
                        this.achievements[key].progress = parsed[key].progress;
                    }
                });
                console.log('🏆 Achievement progress loaded');
            }
        } catch (error) {
            console.log('⚠️ Could not load achievement progress:', error);
        }
    },
    
    reset() {
        // Reset runtime tracking
        this.achievements.speedDemon.timestamps = [];
        this.achievements.perfectAccuracy.startTime = null;
        
        // Update display
        this.updateGalleryDisplay();
        console.log('🏆 Achievement system reset for new game');
    },
    
    destroy() {
        const panel = document.getElementById('achievementGallery');
        if (panel && panel.parentNode) {
            panel.parentNode.removeChild(panel);
        }
        console.log('🏆 Achievement system destroyed');
    }
};

// ========================================================================
// PHASE 3C: ANALYTICS SYSTEM - DETAILED PERFORMANCE METRICS
// ========================================================================
const analyticsSystem = {
    sessionData: {
        startTime: null,
        endTime: null,
        eliminations: [],
        misses: [],
        combos: [],
        reactionTimes: [],
        accuracyHistory: [],
        peakPerformance: {
            bestCombo: 0,
            fastestReaction: Infinity,
            longestAccuracyStreak: 0,
            highestScore: 0
        }
    },
    
    historicalData: [],
    currentSession: null,
    
    init() {
        console.log('📊 Initializing analytics system...');
        this.loadHistoricalData();
        this.startNewSession();
    },
    
    startNewSession() {
        this.currentSession = {
            id: Date.now(),
            startTime: Date.now(),
            endTime: null,
            eliminations: [],
            misses: [],
            combos: [],
            reactionTimes: {
                high: [],
                medium: [],
                low: []
            },
            accuracySnapshots: [],
            performanceMetrics: {
                avgReactionTime: 0,
                peakAccuracy: 0,
                sustainedAccuracy: 0,
                comboEfficiency: 0,
                consistencyScore: 0
            },
            gameEvents: []
        };
        
        console.log('📊 New analytics session started');
    },
    
    trackElimination(distractionType, reactionTime, points, combo) {
        if (!this.currentSession) return;
        
        const elimination = {
            timestamp: Date.now(),
            type: distractionType.name,
            urgency: distractionType.urgency,
            reactionTime: reactionTime,
            points: points,
            combo: combo,
            accuracy: this.calculateCurrentAccuracy()
        };
        
        this.currentSession.eliminations.push(elimination);
        this.currentSession.reactionTimes[distractionType.urgency].push(reactionTime);
        
        // Track peak performance
        if (reactionTime < this.sessionData.peakPerformance.fastestReaction) {
            this.sessionData.peakPerformance.fastestReaction = reactionTime;
        }
        
        if (combo > this.sessionData.peakPerformance.bestCombo) {
            this.sessionData.peakPerformance.bestCombo = combo;
        }
        
        this.updatePerformanceMetrics();
        console.log(`📊 Tracked elimination: ${distractionType.urgency} in ${reactionTime}ms`);
    },
    
    trackMiss(distractionType, missType = 'timeout') {
        if (!this.currentSession) return;
        
        const miss = {
            timestamp: Date.now(),
            type: distractionType.name,
            urgency: distractionType.urgency,
            missType: missType, // 'timeout' or 'incorrect'
            accuracy: this.calculateCurrentAccuracy()
        };
        
        this.currentSession.misses.push(miss);
        this.updatePerformanceMetrics();
        console.log(`📊 Tracked miss: ${distractionType.urgency} (${missType})`);
    },
    
    trackCombo(comboLevel, points) {
        if (!this.currentSession) return;
        
        const combo = {
            timestamp: Date.now(),
            level: comboLevel,
            points: points,
            duration: this.calculateComboDuration()
        };
        
        this.currentSession.combos.push(combo);
        console.log(`📊 Tracked combo: level ${comboLevel} (${points} pts)`);
    },
    
    calculateCurrentAccuracy() {
        const total = gameState.totalDistractions;
        const eliminated = gameState.eliminatedDistractions;
        return total > 0 ? (eliminated / total) * 100 : 100;
    },
    
    calculateComboDuration() {
        const eliminations = this.currentSession.eliminations;
        if (eliminations.length < 2) return 0;
        
        const recent = eliminations.slice(-2);
        return recent[1].timestamp - recent[0].timestamp;
    },
    
    updatePerformanceMetrics() {
        if (!this.currentSession) return;
        
        const session = this.currentSession;
        const eliminations = session.eliminations;
        const misses = session.misses;
        
        // Average reaction time
        const allReactionTimes = [
            ...session.reactionTimes.high,
            ...session.reactionTimes.medium,
            ...session.reactionTimes.low
        ];
        
        session.performanceMetrics.avgReactionTime = allReactionTimes.length > 0 ?
            allReactionTimes.reduce((a, b) => a + b, 0) / allReactionTimes.length : 0;
        
        // Peak accuracy
        session.performanceMetrics.peakAccuracy = Math.max(
            session.performanceMetrics.peakAccuracy,
            this.calculateCurrentAccuracy()
        );
        
        // Combo efficiency (average combo level)
        const combos = session.combos;
        session.performanceMetrics.comboEfficiency = combos.length > 0 ?
            combos.reduce((sum, combo) => sum + combo.level, 0) / combos.length : 0;
        
        // Consistency score (inverse of reaction time variance)
        if (allReactionTimes.length > 2) {
            const avg = session.performanceMetrics.avgReactionTime;
            const variance = allReactionTimes.reduce((sum, time) => sum + Math.pow(time - avg, 2), 0) / allReactionTimes.length;
            session.performanceMetrics.consistencyScore = Math.max(0, 100 - (Math.sqrt(variance) / 10));
        }
        
        // Take accuracy snapshot every 10 eliminations
        if (eliminations.length % 10 === 0) {
            session.accuracySnapshots.push({
                timestamp: Date.now(),
                accuracy: this.calculateCurrentAccuracy(),
                eliminations: eliminations.length
            });
        }
    },
    
    endSession(finalScore) {
        if (!this.currentSession) return;
        
        this.currentSession.endTime = Date.now();
        this.currentSession.finalScore = finalScore;
        this.currentSession.duration = this.currentSession.endTime - this.currentSession.startTime;
        
        // Generate insights and recommendations
        this.generateSessionInsights();
        
        // Save to historical data
        this.historicalData.push(this.currentSession);
        this.saveHistoricalData();
        
        console.log('📊 Analytics session ended with comprehensive data');
        return this.currentSession;
    },
    
    generateSessionInsights() {
        if (!this.currentSession) return;
        
        const session = this.currentSession;
        const insights = {
            strengths: [],
            improvements: [],
            achievements: [],
            recommendations: []
        };
        
        // Analyze reaction times
        const avgReaction = session.performanceMetrics.avgReactionTime;
        if (avgReaction < 800) {
            insights.strengths.push("⚡ Lightning-fast reactions");
        } else if (avgReaction > 1500) {
            insights.improvements.push("🎯 Focus on faster elimination");
            insights.recommendations.push("Try to eliminate distractions as soon as they appear");
        }
        
        // Analyze accuracy
        const accuracy = this.calculateCurrentAccuracy();
        if (accuracy >= 90) {
            insights.strengths.push("🎯 Excellent accuracy");
        } else if (accuracy < 70) {
            insights.improvements.push("📈 Work on precision");
            insights.recommendations.push("Take a moment to aim before tapping distractions");
        }
        
        // Analyze combo performance
        const avgCombo = session.performanceMetrics.comboEfficiency;
        if (avgCombo >= 3) {
            insights.strengths.push("🔥 Great combo mastery");
        } else if (avgCombo < 1.5) {
            insights.improvements.push("⚡ Build more combos");
            insights.recommendations.push("Eliminate distractions quickly in sequence for bonus points");
        }
        
        // Analyze consistency
        const consistency = session.performanceMetrics.consistencyScore;
        if (consistency >= 80) {
            insights.strengths.push("🎯 Very consistent performance");
        } else if (consistency < 50) {
            insights.improvements.push("📊 Improve consistency");
            insights.recommendations.push("Try to maintain steady reaction times throughout the game");
        }
        
        session.insights = insights;
        console.log('📊 Generated session insights:', insights);
    },
    
    getPerformanceReport() {
        if (!this.currentSession) return null;
        
        const session = this.currentSession;
        const duration = (Date.now() - session.startTime) / 1000;
        
        return {
            currentSession: {
                duration: Math.floor(duration),
                eliminations: session.eliminations.length,
                misses: session.misses.length,
                accuracy: this.calculateCurrentAccuracy(),
                avgReactionTime: Math.round(session.performanceMetrics.avgReactionTime),
                bestCombo: Math.max(...session.combos.map(c => c.level), 0),
                consistencyScore: Math.round(session.performanceMetrics.consistencyScore)
            },
            reactionBreakdown: {
                high: this.calculateAverage(session.reactionTimes.high),
                medium: this.calculateAverage(session.reactionTimes.medium),
                low: this.calculateAverage(session.reactionTimes.low)
            },
            trends: this.calculatePerformanceTrends(),
            insights: session.insights || { strengths: [], improvements: [], recommendations: [] }
        };
    },
    
    calculateAverage(array) {
        return array.length > 0 ? Math.round(array.reduce((a, b) => a + b, 0) / array.length) : 0;
    },
    
    calculatePerformanceTrends() {
        if (!this.currentSession || this.currentSession.eliminations.length < 5) {
            return { trend: 'insufficient_data', direction: 'neutral' };
        }
        
        const eliminations = this.currentSession.eliminations;
        const recentElims = eliminations.slice(-5);
        const earlierElims = eliminations.slice(0, 5);
        
        const recentAvg = this.calculateAverage(recentElims.map(e => e.reactionTime));
        const earlierAvg = this.calculateAverage(earlierElims.map(e => e.reactionTime));
        
        const improvement = ((earlierAvg - recentAvg) / earlierAvg) * 100;
        
        if (improvement > 10) {
            return { trend: 'improving', direction: 'up', improvement: Math.round(improvement) };
        } else if (improvement < -10) {
            return { trend: 'declining', direction: 'down', decline: Math.round(Math.abs(improvement)) };
        } else {
            return { trend: 'stable', direction: 'steady' };
        }
    },
    
    saveHistoricalData() {
        try {
            // Keep only last 10 sessions to avoid storage bloat
            const dataToSave = this.historicalData.slice(-10);
            localStorage.setItem('endlessEmbrace_analytics', JSON.stringify(dataToSave));
            console.log('📊 Analytics data saved');
        } catch (error) {
            console.log('⚠️ Could not save analytics data:', error);
        }
    },
    
    loadHistoricalData() {
        try {
            const savedData = localStorage.getItem('endlessEmbrace_analytics');
            if (savedData) {
                this.historicalData = JSON.parse(savedData);
                console.log(`📊 Loaded ${this.historicalData.length} historical sessions`);
            }
        } catch (error) {
            console.log('⚠️ Could not load analytics data:', error);
            this.historicalData = [];
        }
    },
    
    reset() {
        if (this.currentSession) {
            this.endSession(gameState.score);
        }
        this.startNewSession();
        console.log('📊 Analytics system reset for new game');
    },
    
    destroy() {
        if (this.currentSession) {
            this.endSession(gameState.score);
        }
        console.log('📊 Analytics system destroyed');
    }
};

// ========================================================================
// THREE.JS INTEGRATION SYSTEM
// ========================================================================
const threeManager = {
    scene: null,
    camera: null,
    renderer: null,
    container: null,
    animationId: null,
    isInitialized: false,
    
    // Three.js objects
    heartParticles: [],
    ambientObjects: [],
    backgroundElements: [],
    
    init() {
        console.log('🌟 Initializing Three.js system...');
        
        try {
            this.container = document.getElementById('threeContainer');
            if (!this.container) {
                console.error('❌ Three.js container not found');
                return;
            }
            
            // Scene setup
            this.scene = new THREE.Scene();
            
            // Camera setup
            this.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            this.camera.position.z = 5;
            
            // Renderer setup
            this.renderer = new THREE.WebGLRenderer({ 
                alpha: true, 
                antialias: true 
            });
            // Three.js Container Positioning
            this.container.style.position = 'fixed';
            this.container.style.top = '0px';
            this.container.style.left = '0px';
            this.container.style.width = '100vw';
            this.container.style.height = '100vh';
            this.container.style.zIndex = '10'; // Above background, below particles
            this.container.style.pointerEvents = 'none';
            this.container.style.overflow = 'visible';

        // Renderer setup with viewport dimensions
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x000000, 0); // Transparent background

        this.container.appendChild(this.renderer.domElement);

       // Makes sure renderer canvas fills container
        this.renderer.domElement.style.position = 'absolute';
        this.renderer.domElement.style.top = '0px';
        this.renderer.domElement.style.left = '0px';
        this.renderer.domElement.style.width = '100%';
        this.renderer.domElement.style.height = '100%';
        this.renderer.domElement.style.display = 'block';
            
            // Create ambient scene
            this.createAmbientScene();
            
            // Start animation loop
            this.startAnimation();
            
            // Handle window resize
            window.addEventListener('resize', () => this.onWindowResize());
            
            this.isInitialized = true;
            console.log('✅ Three.js system initialized');
            
        } catch (error) {
            console.error('❌ Three.js initialization failed:', error);
        }
    },
    
    createAmbientScene() {
        // Create floating ambient particles
        this.createFloatingHearts();
        this.createAmbientParticles();
        this.createBackgroundEffects();
    },
    
    createFloatingHearts() {
        const heartGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const heartMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xd5365a,
            transparent: true,
            opacity: 0.6
        });
        
        for (let i = 0; i < 15; i++) {
            const heart = new THREE.Mesh(heartGeometry, heartMaterial);
            
            // Random positions
            heart.position.x = (Math.random() - 0.5) * 10;
            heart.position.y = (Math.random() - 0.5) * 10;
            heart.position.z = (Math.random() - 0.5) * 10;
            
            // Random velocities for floating effect
            heart.userData = {
                velocity: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                originalOpacity: 0.6,
                pulsePhase: Math.random() * Math.PI * 2
            };
            
            this.scene.add(heart);
            this.heartParticles.push(heart);
        }
        
        console.log('💖 Created floating hearts');
    },
    
    createAmbientParticles() {
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 100;
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 20;     // x
            positions[i + 1] = (Math.random() - 0.5) * 20; // y
            positions[i + 2] = (Math.random() - 0.5) * 20; // z
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xFFD700,
            size: 0.05,
            transparent: true,
            opacity: 0.8
        });
        
        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        this.scene.add(particleSystem);
        this.ambientObjects.push(particleSystem);
        
        console.log('✨ Created ambient particle system');
    },
    
    createBackgroundEffects() {
        // Create rotating ring effect
        const ringGeometry = new THREE.RingGeometry(2, 2.1, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0xd5365a,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.z = -3;
        ring.userData = { rotationSpeed: 0.01 };
        
        this.scene.add(ring);
        this.backgroundElements.push(ring);
        
        console.log('🔄 Created background effects');
    },
    
    // Game event responses
    onEliminateDistraction(x, y, urgency) {
        if (!this.isInitialized) return;
        
        // Convert screen coordinates to Three.js world coordinates
        const worldPos = this.screenToWorld(x, y);
        this.createEliminationEffect(worldPos, urgency);
    },
    
    onComboAchieved(comboLevel) {
        if (!this.isInitialized) return;
        
        this.createComboEffect(comboLevel);
    },
    
    onMilestoneReached(milestone) {
        if (!this.isInitialized) return;
        
        this.createMilestoneEffect(milestone);
    },
    
    screenToWorld(screenX, screenY) {
        const vector = new THREE.Vector3();
        vector.x = (screenX / window.innerWidth) * 2 - 1;
        vector.y = -(screenY / window.innerHeight) * 2 + 1;
        vector.z = 0.5;
        
        vector.unproject(this.camera);
        return vector;
    },
    
    createEliminationEffect(worldPos, urgency) {
        // Create burst effect at elimination point
        const burstGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const burstColor = urgency === 'high' ? 0xff4444 : 
                          urgency === 'medium' ? 0xffaa00 : 0x44ff88;
        const burstMaterial = new THREE.MeshBasicMaterial({
            color: burstColor,
            transparent: true,
            opacity: 1
        });
        
        const burst = new THREE.Mesh(burstGeometry, burstMaterial);
        burst.position.copy(worldPos);
        burst.userData = {
            scale: 0.1,
            opacity: 1,
            life: 1.0,
            type: 'elimination'
        };
        
        this.scene.add(burst);
        this.ambientObjects.push(burst);
        
        console.log('💥 Created Three.js elimination effect');
    },
    
    createComboEffect(comboLevel) {
        // Create expanding ring effect for combos
        const ringGeometry = new THREE.RingGeometry(0.5, 0.6, 16);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6b6b,
            transparent: true,
            opacity: 0.8
        });
        
        for (let i = 0; i < comboLevel; i++) {
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(0, 0, 2);
            ring.userData = {
                scale: 0.1,
                targetScale: 2 + i * 0.5,
                opacity: 0.8,
                type: 'combo',
                delay: i * 100
            };
            
            this.scene.add(ring);
            this.ambientObjects.push(ring);
        }
        
        console.log(`🔥 Created Three.js combo effect level ${comboLevel}`);
    },
    
    createMilestoneEffect(milestone) {
        // Create celebration burst
        for (let i = 0; i < 20; i++) {
            const starGeometry = new THREE.SphereGeometry(0.05, 6, 6);
            const starMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 1
            });
            
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set(
                (Math.random() - 0.5) * 4,
                (Math.random() - 0.5) * 4,
                (Math.random() - 0.5) * 4
            );
            star.userData = {
                velocity: {
                    x: (Math.random() - 0.5) * 0.1,
                    y: (Math.random() - 0.5) * 0.1,
                    z: (Math.random() - 0.5) * 0.1
                },
                life: 1.0,
                type: 'milestone'
            };
            
            this.scene.add(star);
            this.ambientObjects.push(star);
        }
        
        console.log('🎉 Created Three.js milestone effect');
    },
    
    update() {
        if (!this.isInitialized) return;
        
        // Update floating hearts
        this.heartParticles.forEach(heart => {
            // Floating movement
            heart.position.x += heart.userData.velocity.x;
            heart.position.y += heart.userData.velocity.y;
            heart.position.z += heart.userData.velocity.z;
            
            // Boundary wrapping
            if (Math.abs(heart.position.x) > 5) heart.userData.velocity.x *= -1;
            if (Math.abs(heart.position.y) > 5) heart.userData.velocity.y *= -1;
            if (Math.abs(heart.position.z) > 5) heart.userData.velocity.z *= -1;
            
            // Pulsing effect
            heart.userData.pulsePhase += 0.05;
            const pulse = Math.sin(heart.userData.pulsePhase) * 0.2 + 0.8;
            heart.material.opacity = heart.userData.originalOpacity * pulse;
            
            // Gentle rotation
            heart.rotation.x += 0.01;
            heart.rotation.y += 0.015;
        });
        
        // Update background elements
        this.backgroundElements.forEach(element => {
            if (element.userData.rotationSpeed) {
                element.rotation.z += element.userData.rotationSpeed;
            }
        });
        
        // Update effect objects
        for (let i = this.ambientObjects.length - 1; i >= 0; i--) {
            const obj = this.ambientObjects[i];
            const userData = obj.userData;
            
            if (userData.type === 'elimination') {
                userData.scale += 0.1;
                userData.opacity -= 0.03;
                obj.scale.setScalar(userData.scale);
                obj.material.opacity = userData.opacity;
                
                if (userData.opacity <= 0) {
                    this.scene.remove(obj);
                    this.ambientObjects.splice(i, 1);
                }
            } else if (userData.type === 'combo') {
                if (userData.delay > 0) {
                    userData.delay -= 16; // Assuming 60fps
                } else {
                    userData.scale += (userData.targetScale - userData.scale) * 0.1;
                    userData.opacity -= 0.02;
                    obj.scale.setScalar(userData.scale);
                    obj.material.opacity = userData.opacity;
                    
                    if (userData.opacity <= 0) {
                        this.scene.remove(obj);
                        this.ambientObjects.splice(i, 1);
                    }
                }
            } else if (userData.type === 'milestone') {
                obj.position.x += userData.velocity.x;
                obj.position.y += userData.velocity.y;
                obj.position.z += userData.velocity.z;
                userData.life -= 0.02;
                obj.material.opacity = userData.life;
                
                if (userData.life <= 0) {
                    this.scene.remove(obj);
                    this.ambientObjects.splice(i, 1);
                }
            }
        }
    },
    
    // Three.js Resize Handler
onWindowResize() {
    if (!this.isInitialized) return;
    
    // Simple viewport-based resize
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    // Update container size
    if (this.container) {
        this.container.style.width = width + 'px';
        this.container.style.height = height + 'px';
    }
    
    // Update camera aspect ratio
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    
    // Update renderer size
    this.renderer.setSize(width, height);
    
    console.log(`🔄 Three.js resized to ${width}x${height}`);
},
    startAnimation() {
        const animate = () => {
            this.update();
            if (this.renderer && this.scene && this.camera) {
                this.renderer.render(this.scene, this.camera);
            }
            this.animationId = requestAnimationFrame(animate);
        };
        animate();
        console.log('✅ Three.js animation started');
    },
    
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        if (this.renderer) {
            this.renderer.dispose();
        }
        if (this.container && this.renderer) {
            this.container.removeChild(this.renderer.domElement);
        }
        this.isInitialized = false;
        console.log('🗑️ Three.js system destroyed');
    }
};

// ========================================================================
// GAME LOGIC
// ========================================================================
async function startGame() {
    console.log('🚀 Starting game...');
    
    gameState.reset();
    gameState.gameRunning = true;
    gameState.gameStartTime = Date.now();
    gameState.currentSilhouetteLevel = 1;
    
    // Force audio context start and background music
    try {
        await audioManager.ensureAudioContext();
        
        // Force resume audio context
        if (audioManager.audioContext && audioManager.audioContext.state === 'suspended') {
            await audioManager.audioContext.resume();
            console.log('🎵 Audio context force resumed');
        }
        
        // Ensure tear sounds are available
        if (audioManager && !audioManager.isInitialized) {
            audioManager.generateSounds();
            console.log('🎵 Tear sound effects ready');
        }
        
        // Start background music with delay
        setTimeout(() => {
            audioManager.playBackgroundMusic();
            console.log('🎵 Background music initialization attempted');
        }, 500);
        
    } catch (error) {
        console.warn('Audio initialization failed:', error);
    }
    
    // Initialize particle system
    particleSystem.init();
    
    // Initialize Three.js system
    threeManager.init();
    
    // PHASE 3C: Initialize animated background
    backgroundEffects.init();

    // PHASE 3C: Initialize achievement system
    achievementSystem.init();

    // PHASE 3C: Initialize nalytics system
    analyticsSystem.init();
    
    updateProgressiveSilhouette(0);
    
    showScreen('gameScreen');
    gameState.animationFrame = requestAnimationFrame(gameLoop);
    updateHUD();
    
    setTimeout(spawnDistraction, 700);
    
    setTimeout(() => { 
        showGameplayMessage('Focus on eliminating distractions!', 'Tap quickly for combos'); 
    }, 2000);
    
    console.log('✅ Game started successfully with all systems');
}

// Game loop for movement updates
function gameLoop() {
    if (!gameState.gameRunning) return;
    
    // Update all distraction movements
    distractionMovement.updateMovements();
    
    // Continue loop
    gameState.animationFrame = requestAnimationFrame(gameLoop);
}

function spawnDistraction() {
    if (!gameState.gameRunning || gameState.gameEnding) {
        console.log('🛑 Not spawning - game not running');
        return;
    }
    
    // Initialize spawn interval on first call 
    if (!timerManager.spawnInterval && !timerManager.spawnIntervalInitialized) {
        timerManager.spawnIntervalInitialized = true;
        timerManager.lastSpawnAttempt = Date.now();
        
        timerManager.spawnInterval = setInterval(() => {
            if (!gameState.gameRunning || gameState.gameEnding) {
                clearInterval(timerManager.spawnInterval);
                timerManager.spawnInterval = null;
                timerManager.spawnIntervalInitialized = false;
                console.log('🛑 Spawn interval stopped');
                return;
            }
            
            const now = Date.now();
            const timeSinceLastAttempt = now - timerManager.lastSpawnAttempt;
            const requiredDelay = getAdaptiveSpawnDelay();
            
            if (timeSinceLastAttempt >= requiredDelay) {
                attemptSpawn();
                timerManager.lastSpawnAttempt = now;
            }
        }, 50); // Check every 50ms for precise timing
        
        timerManager.addInterval(timerManager.spawnInterval);
        console.log('✅ Spawn interval system initialized (no more recursive timeouts)');
    }
    
    // Execute the spawn logic immediately for the first call
    attemptSpawn();
}

// Extract spawn logic to separate function to avoid duplication
function attemptSpawn() {
    if (!gameState.gameRunning || gameState.gameEnding) {
        return;
    }
    
    const activeCount = gameState.distractions.length;
    const gameTimeSeconds = (Date.now() - gameState.gameStartTime) / 1000;
    
    let maxAllowed;
    if (gameTimeSeconds < 15) {
        maxAllowed = 1;
    } else if (gameTimeSeconds < 30) {
        maxAllowed = gameState.isMobile ? 1 : 2;
    } else {
        maxAllowed = gameState.isMobile ? 2 : 3;
    }
    
    if (activeCount >= maxAllowed) {
        console.log(`🛡️ Overlap prevention: ${activeCount}/${maxAllowed} active - skipping spawn`);
        return; 
    }
    
    console.log('📦 Spawning distraction...');
    
    const distractionType = distractionTypes[Math.floor(Math.random() * distractionTypes.length)];
    const movementType = distractionMovement.getMovementType();
    gameState.totalDistractions++;
    
    const distraction = createDistraction(distractionType);
    
    const gameScreen = document.getElementById('gameScreen');
    const position = findNonOverlappingPosition();
    
    distraction.style.position = 'fixed';
    distraction.style.left = position.x + 'px';
    distraction.style.top = position.y + 'px';
    distraction.style.zIndex = '100';
    
    gameScreen.appendChild(distraction);
    gameState.distractions.push(distraction);

    // Initialize movement system
    distractionMovement.initializeMovement(distraction, movementType);
    
    console.log(`🔍 Spawned ${movementType} ${distractionType.urgency} priority ${distractionType.name} (${distractionType.points} pts) - Active: ${gameState.distractions.length}/${maxAllowed}`);
    
    // PHASE 3C: Periodic achievement checks (survival time, etc.)
    if (typeof achievementSystem !== 'undefined') {
        achievementSystem.checkAchievements();
    }
    
    const timeoutId = timerManager.addTimeout(setTimeout(() => {
        failDistraction(distraction);
    }, getMobileAdjustedTimeout(distractionType, movementType)));
    
}

function findNonOverlappingPosition() {
    const margin = 120;
    const distractionSize = 80;
    
    for (let attempts = 0; attempts < 10; attempts++) {
        const x = margin + Math.random() * (window.innerWidth - 2 * margin - distractionSize);
        const y = margin + Math.random() * (window.innerHeight - 2 * margin - distractionSize);
        
        let overlaps = false;
        for (let existing of gameState.distractions) {
            if (existing.parentNode) {
                const existingX = parseInt(existing.style.left);
                const existingY = parseInt(existing.style.top);
                const distance = Math.sqrt(Math.pow(x - existingX, 2) + Math.pow(y - existingY, 2));
                
                if (distance < 150) {
                    overlaps = true;
                    break;
                }
            }
        }
        
        if (!overlaps) {
            return { x, y };
        }
    }
    
    return {
        x: margin + Math.random() * (window.innerWidth - 2 * margin - distractionSize),
        y: margin + Math.random() * (window.innerHeight - 2 * margin - distractionSize)
    };
}

// 🎯 FOMO-OPTIMIZED ADAPTIVE SPAWN DELAY - "Almost But Not Quite" Difficulty
function getAdaptiveSpawnDelay() {
    const gameTimeSeconds = (Date.now() - gameState.gameStartTime) / 1000;
    
    let baseDelay, phase, speedBoostPercent;
    
    // Psychological progression - easy start, brutal finish for FOMO
    if (gameTimeSeconds < 15) {
        baseDelay = 700;  // 15% faster: 800ms → 700ms (Confidence Building)
        phase = "Confidence Phase";
        speedBoostPercent = 15;
    } else if (gameTimeSeconds < 35) {
        baseDelay = 400;  // 45% faster: 700ms → 400ms (Reality Check)
        phase = "Reality Check";
        speedBoostPercent = 45;
    } else if (gameTimeSeconds < 60) {
        baseDelay = 200;  // 70% faster: 650ms → 200ms (Skill Wall)
        phase = "Skill Wall";
        speedBoostPercent = 70;
    } else if (gameTimeSeconds < 90) {
        baseDelay = 120;  // 82% faster: 650ms → 120ms (Elite Barrier)
        phase = "Elite Barrier";
        speedBoostPercent = 82;
    } else {
        // Mobile-friendly master level
    if (gameState.isMobile) {
        baseDelay = 140;  // +75% more time for mobile touch
        speedBoostPercent = 78;
        phase = "Master's Gauntlet (Mobile)";
    } else {
        baseDelay = 80;   // Desktop brutal
        speedBoostPercent = 88;
        phase = "Master's Gauntlet";
    }
}
    
    // Aggressive score acceleration that punishes high scores
    const scoreReduction = Math.min(gameState.score * 1.3, 200); // Increased difficulty with success
    
    // Combo acceleration that becomes overwhelming
    const comboReduction = gameState.combo > 0 ? Math.min(gameState.combo * 35, 140) : 0;
    
    // Movement chaos multiplier
    const movingCount = gameState.distractions ? 
        gameState.distractions.filter(d => d.movementType && d.movementType !== 'static').length : 0;
    const movementBonus = movingCount * 8; // Significant speed increase
    
    // Calculate preliminary delay
    let preliminaryDelay = baseDelay - scoreReduction - comboReduction - movementBonus;
    
    // Psychological minimum delays - designed to create failure at master level
    const minimumDelay = gameTimeSeconds < 15 ? (gameState.isMobile ? 550 : 500) :    // Confidence: Only +50ms mobile
                    gameTimeSeconds < 35 ? (gameState.isMobile ? 300 : 250) :     // Reality: +50ms mobile  
                    gameTimeSeconds < 60 ? (gameState.isMobile ? 180 : 140) :     // Skill Wall: +40ms mobile
                    gameTimeSeconds < 90 ? (gameState.isMobile ? 120 : 90) :      // Elite: +30ms mobile
                    (gameState.isMobile ? 95 : 65);                               // Master: +30ms mobile
    
    preliminaryDelay = Math.max(preliminaryDelay, minimumDelay);
    
    // Apply FOMO-tuned overlap prevention
    const finalDelay = applyFOMOOverlapPrevention(preliminaryDelay, gameTimeSeconds);
    
    // Psychological logging with FOMO messaging
    const originalDelay = 800;
    const actualSpeedIncrease = ((originalDelay - finalDelay) / originalDelay * 100).toFixed(0);
    
    // Special messaging for different phases
    if (gameTimeSeconds < 15) {
        console.log(`😊 ${phase}: ${finalDelay}ms - You've got this!`);
    } else if (gameTimeSeconds < 35) {
        console.log(`😐 ${phase}: ${finalDelay}ms (${actualSpeedIncrease}% faster) - Getting serious...`);
    } else if (gameTimeSeconds < 60) {
        console.log(`😰 ${phase}: ${finalDelay}ms (${actualSpeedIncrease}% faster) - This is where it gets tough!`);
    } else if (gameTimeSeconds < 90) {
        console.log(`🔥 ${phase}: ${finalDelay}ms (${actualSpeedIncrease}% faster) - Elite territory!`);
    } else {
        console.log(`🚨 ${phase}: ${finalDelay}ms (${actualSpeedIncrease}% faster) - MASTER LEVEL - Few survive this!`);
    }
    
    // FOMO trigger warnings
    if (gameTimeSeconds > 60 && finalDelay < 100) {
        console.log(`⚡ ENTERING MASTER TERRITORY - Only 5% of players reach this level!`);
    }
    if (gameTimeSeconds > 90) {
        console.log(`🏆 MASTER'S GAUNTLET ACTIVE - Prove you're in the top 1%!`);
    }
    
    return finalDelay;
}

// FOMO-optimized overlap prevention - allows overwhelming situations
function applyFOMOOverlapPrevention(proposedDelay, gameTimeSeconds) {
    const activeDistractions = gameState.distractions.length;
    const isMobile = gameState.isMobile;
    
    // Less protection in later phases to increase difficulty
    let minDelay;
    
    if (activeDistractions === 0) {
        minDelay = proposedDelay;
    } else if (activeDistractions === 1) {
        // Minimal protection - let players get overwhelmed
        minDelay = Math.max(proposedDelay, isMobile ? 140 : 120);
    } else if (activeDistractions >= 2) {
        // Allow chaos in master phases for authentic difficulty
        if (gameTimeSeconds > 60) {
            minDelay = Math.max(proposedDelay, isMobile ? 120 : 100); // Less protection
        } else {
            minDelay = Math.max(proposedDelay, isMobile ? 200 : 200);
        }
    }
    
    // Phase-based minimums designed for psychological progression
    let phaseMinimum;
    if (gameTimeSeconds < 15) {
        phaseMinimum = isMobile ? 420 : 400;  // Confidence: Build false confidence
    } else if (gameTimeSeconds < 35) {
        phaseMinimum = isMobile ? 140 : 160;  // Reality: Wake-up call
    } else if (gameTimeSeconds < 60) {
        phaseMinimum = isMobile ? 90 : 90;   // Skill Wall: Real challenge begins
    } else if (gameTimeSeconds < 90) {
        phaseMinimum = isMobile ? 60 : 60;    // Elite: Separates good from great
    } else {
        phaseMinimum = isMobile ? 45 : 40;    // Master: Deliberately brutal
    }
    
    const finalDelay = Math.max(minDelay, phaseMinimum);
    
    return finalDelay;
}

console.log("🎯 FOMO-OPTIMIZED SPAWN SYSTEM LOADED!");
console.log("🧠 Psychological Progression Design:");
console.log("- Confidence Phase (0-15s): 15% faster - Build false confidence");
console.log("- Reality Check (15-35s): 45% faster - Wake-up call"); 
console.log("- Skill Wall (35-60s): 70% faster - Real challenge begins");
console.log("- Elite Barrier (60-90s): 82% faster - Separate good from great");
console.log("- Master's Gauntlet (90s+): 88% faster - Only 1% survive");
console.log("🎮 Designed for addictive frustration and comeback motivation!");

function applyOverlapPrevention(proposedDelay, gameTimeSeconds) {
    // Simple counter approach - no complex timing
    if (!this.simpleCounter) {
        this.simpleCounter = 0;
        this.lastReset = Date.now();
    }
    
    const now = Date.now();
    
    // Reset counter every 2 seconds
    if (now - this.lastReset > 2000) {
        this.simpleCounter = 0;
        this.lastReset = now;
    }
    
    this.simpleCounter++;
    
    // Simple escape after 3 attempts (reduced for faster recovery)
    if (this.simpleCounter > 3) {
        console.log("🚨 ESCAPE: Overlap limit reached - allowing spawn");
        this.simpleCounter = 0;
        this.lastReset = now;
        return proposedDelay; // Allow spawn with original proposed delay
    }
    
    // Existing overlap prevention logic
    const activeDistractions = gameState.distractions.length;
    const isMobile = gameState.isMobile;
    
    let minDelay;
    
    if (activeDistractions === 0) {
        minDelay = proposedDelay;
    } else if (activeDistractions === 1) {
        if (isMobile) {
            minDelay = Math.max(proposedDelay, 1100);
        } else {
            minDelay = Math.max(proposedDelay, 850);
        }
    } else {
        if (isMobile) {
            minDelay = Math.max(proposedDelay, 1600);
        } else {
            minDelay = Math.max(proposedDelay, 1300);
        }
    }
    
    let phaseMinimum;
    if (gameTimeSeconds < 15) {
        phaseMinimum = isMobile ? 800 : 650;
    } else if (gameTimeSeconds < 30) {
        phaseMinimum = isMobile ? 700 : 550;
    } else {
        phaseMinimum = isMobile ? 600 : 450;
    }
    
    const finalDelay = Math.max(minDelay, phaseMinimum);
    
    if (activeDistractions > 0) {
        console.log(`🛡️ Overlap prevention: ${activeDistractions} active → ${finalDelay}ms delay (attempt ${this.simpleCounter})`);
    }
    
    return finalDelay;
}
function eliminateDistraction(distraction, distractionType) {
    // Safety check - ensure distraction exists and has parent
    if (!distraction || !distraction.parentNode) {
        console.warn('⚠️ Invalid distraction passed to eliminateDistraction');
        return;
    }
    
    // Get distractionType from parameter or distraction object
    const type = distractionType || distraction.distractionType;
    if (!type) {
        console.warn('⚠️ No distraction type found');
        return;
    }
    
    const currentTime = Date.now();
    const spawnTime = distraction.dataset.spawnTime || distraction.spawnTime || currentTime;
    const responseTime = currentTime - spawnTime;
    
    // Clean up movement system if available
    if (typeof distractionMovement !== 'undefined' && distractionMovement.onDistractionRemoved) {
        distractionMovement.onDistractionRemoved(distraction);
    }
    
    // BASE POINTS CALCULATION
    const basePoints = parseInt(type.points) || 10;
    
    // SPEED/MOVEMENT BONUS
    let speedBonus = 0;
    if (distraction.speedMultiplier && distraction.speedMultiplier > 1) {
        speedBonus = Math.floor(basePoints * (distraction.speedMultiplier - 1) * 0.5);
    }
    
    // TIME BONUS - reward quick reactions
    let timeBonus = Math.max(0, Math.floor((2000 - responseTime) / 100));
    
    // COMBO SYSTEM - logic
    let comboMultiplier = 1;
    let comboBonus = 0;
    const timeSinceLastElimination = currentTime - (gameState.lastEliminationTime || 0);
    
    if (timeSinceLastElimination < 1500) { // Combo window
        gameState.combo = (gameState.combo || 0) + 1;
        comboMultiplier = 1 + (gameState.combo * 0.25);
        comboBonus = Math.floor(basePoints * (gameState.combo - 1) * 0.2);
        console.log(`🔥 COMBO x${gameState.combo}! Multiplier: ${comboMultiplier.toFixed(2)}`);
    } else {
        if (gameState.combo > 0) {
            console.log(`💫 Combo ended at x${gameState.combo}`);
        }
        gameState.combo = 1;
        comboMultiplier = 1;
    }
    
    // FINAL POINTS CALCULATION
    const subtotalPoints = basePoints + speedBonus + timeBonus + comboBonus;
    const finalPoints = Math.round(subtotalPoints * comboMultiplier);
    
    // UPDATE GAME STATE
    gameState.score += finalPoints;
    gameState.eliminatedDistractions = (gameState.eliminatedDistractions || 0) + 1;
    gameState.lastEliminationTime = currentTime;
    
    console.log(`✅ ${type.name} eliminated! +${finalPoints} pts (base: ${basePoints}, speed: +${speedBonus}, time: +${timeBonus}, combo: +${comboBonus}, multiplier: x${comboMultiplier.toFixed(2)})`);
    
    // PARTICLE EFFECTS
    const rect = distraction.getBoundingClientRect();
    const particleX = rect.left + rect.width / 2;
    const particleY = rect.top + rect.height / 2;
    
    if (typeof particleSystem !== 'undefined') {
        if (gameState.combo >= 2) {
            if (particleSystem.createComboBurst) {
                particleSystem.createComboBurst(particleX, particleY, gameState.combo);
            } else if (particleSystem.createBurst) {
                particleSystem.createBurst(particleX, particleY, '#ffdd00'); // Gold for combo
            }
        } else {
            const particleColor = type.urgency === 'high' ? '#ff6b6b' : 
                                 type.urgency === 'medium' ? '#ffa500' : '#44ff88';
            if (particleSystem.createEliminationBurst) {
                particleSystem.createEliminationBurst(particleX, particleY, particleColor);
            } else if (particleSystem.createBurst) {
                particleSystem.createBurst(particleX, particleY, particleColor);
            }
        }
    }
    
    // THREE.JS EFFECTS
    if (typeof threeManager !== 'undefined') {
        if (gameState.combo >= 2 && threeManager.onComboAchieved) {
            threeManager.onComboAchieved(gameState.combo);
        } else if (threeManager.onEliminateDistraction) {
            threeManager.onEliminateDistraction(particleX, particleY, type.urgency);
        }
    }
    
    // SCREEN SHAKE EFFECTS
    if (typeof screenShake !== 'undefined') {
        if (gameState.combo >= 3) {
            if (screenShake.combo) {
                screenShake.combo(gameState.combo);
            } else if (screenShake.moderate) {
                screenShake.moderate();
            }
            console.log(`📳 Combo shake triggered: level ${gameState.combo}`);
        } else if (type.urgency === 'high' && finalPoints > 30) {
            if (screenShake.moderate) {
                screenShake.moderate();
            } else if (screenShake.subtle) {
                screenShake.subtle();
            }
            console.log('📳 High-value elimination shake');
        } else if (finalPoints > 40 || distraction.movementType === 'phantom') {
            if (screenShake.subtle) {
                screenShake.subtle();
            }
            console.log('📳 Special elimination shake');
        } else if (finalPoints > 20) {
            if (screenShake.elimination) {
                screenShake.elimination();
            } else if (screenShake.subtle) {
                screenShake.subtle();
            }
            console.log('📳 Standard elimination shake');
        }
    }
    
    // BACKGROUND EFFECTS BOOST
    if (typeof backgroundEffects !== 'undefined' && gameState.combo >= 3) {
        if (backgroundEffects.boostSpeed) {
            backgroundEffects.boostSpeed(1.5);
        }
    }
    
    // AUDIO EFFECTS
    if (typeof audioManager !== 'undefined') {
        // Special phantom sound handling
        if (distraction.movementType === 'phantom') {
            // Phantom sound is handled in movement system
        } else {
            // Standard elimination sound
            if (audioManager.play) {
                audioManager.play('eliminate', 'normal');
            } else if (audioManager.playSound) {
                audioManager.playSound('eliminate');
            }
            console.log(`🎵 Playing eliminate sound`);
        }
        
        // Combo sounds
        if (gameState.combo >= 2) {
            setTimeout(() => {
                if (audioManager.play) {
                    audioManager.play('combo', 'combo');
                } else if (audioManager.playSound) {
                    audioManager.playSound('combo');
                }
                console.log(`🎵 Playing combo sound for combo x${gameState.combo}`);
            }, 50);
        }
        
        // High score sound for exceptional eliminations
        if (type.urgency === 'high' && finalPoints > 30) {
            setTimeout(() => {
                if (audioManager.play) {
                    audioManager.play('highScore');
                } else if (audioManager.playSound) {
                    audioManager.playSound('highScore');
                }
                console.log(`🎵 Playing high score sound`);
            }, 100);
        }
    }
    
    // VISUAL FEEDBACK
    if (typeof showPointPopup !== 'undefined') {
        showPointPopup(distraction, finalPoints, gameState.combo, type.urgency);
    }
    
    if (typeof showComboMessage !== 'undefined' && gameState.combo >= 2) {
        showComboMessage(gameState.combo, finalPoints);
    }
    
    // ACHIEVEMENT MILESTONES
    if (gameState.score === 100) {
        if (typeof showAchievementMessage !== 'undefined') {
            showAchievementMessage('First Century!', '100 points reached');
        }
    } else if (gameState.score === 500) {
        if (typeof showAchievementMessage !== 'undefined') {
            showAchievementMessage('Focus Master!', '500 points achieved');
        }
    } else if (gameState.score === 1000) {
        if (typeof showAchievementMessage !== 'undefined') {
            showAchievementMessage('Legendary Focus!', '1000 points milestone');
        }
    }
    
    // ANALYTICS TRACKING
    if (typeof analyticsSystem !== 'undefined') {
        if (analyticsSystem.trackElimination) {
            analyticsSystem.trackElimination(type, responseTime, finalPoints, gameState.combo);
        }
        if (gameState.combo >= 2 && analyticsSystem.trackCombo) {
            analyticsSystem.trackCombo(gameState.combo, finalPoints);
        }
    }
    
    if (typeof analytics !== 'undefined' && analytics.recordElimination) {
        analytics.recordElimination(type.name, responseTime, finalPoints);
    }
    
    // ACHIEVEMENT SYSTEM CHECK
    if (typeof achievementSystem !== 'undefined' && achievementSystem.checkAchievements) {
        achievementSystem.checkAchievements();
    }
    
    // PROGRESSIVE SILHOUETTE UPDATE
    if (typeof updateProgressiveSilhouette !== 'undefined') {
        updateProgressiveSilhouette(gameState.score);
    }
    
    // HUD UPDATE
    if (typeof updateHUD !== 'undefined') {
        updateHUD();
    }
    
    // LEVEL PROGRESSION
    if (gameState.level) {
        const eliminationsForNextLevel = gameState.level * 10;
        if (gameState.eliminatedDistractions >= eliminationsForNextLevel) {
            if (typeof levelUp !== 'undefined') {
                levelUp();
            }
        }
    }
    
    // CLEANUP - Remove distraction from DOM and arrays
    distraction.remove();
    
    // Remove from distractions array if it exists
    if (gameState.distractions && Array.isArray(gameState.distractions)) {
        const index = gameState.distractions.indexOf(distraction);
        if (index > -1) {
            gameState.distractions.splice(index, 1);
        }
    }
    
    // GAME COMPLETION CHECK
    if (typeof checkGameCompletion !== 'undefined') {
        checkGameCompletion();
    }
    
    // Final log with movement type if available
    const movementType = distraction.movementType ? `${distraction.movementType} ` : '';
    console.log(`💥 ${movementType}${type.name} eliminated! +${finalPoints} pts (combo: ${gameState.combo}, response: ${responseTime}ms)`);
}
function showPointPopup(element, points, combo, urgency) {
    const popup = document.createElement('div');
    popup.className = `point-popup urgency-${urgency}`;
    
    const rect = element.getBoundingClientRect();
    popup.style.position = 'fixed';
    popup.style.left = rect.left + 'px';
    popup.style.top = rect.top + 'px';
    popup.style.zIndex = '200';
    popup.style.pointerEvents = 'none';
    
    let content = `+${points}`;
    if (combo > 0) {
        content += ` <span class="combo-text">x${combo}</span>`;
    }
    
    popup.innerHTML = `<span class="point-text">${content}</span>`;
    
    document.body.appendChild(popup);
    
    console.log(`💫 Point popup shown: ${points} pts${combo > 0 ? ` (x${combo} combo)` : ''}`);
    
    setTimeout(() => {
        if (popup.parentNode) {
            popup.remove();
        }
    }, 1200);
}

function failDistraction(distraction) {
    if (!distraction.parentNode) return;
    
    console.log('❌ Distraction failed');
    
    gameState.lives--;
    updateHUD();

    // PHASE 3C: Check achievements after miss (for tracking accuracy-based achievements)
    achievementSystem.checkAchievements();
    // PHASE 3C: Track miss analytics
    const distractionType = {
    name: distraction.dataset.type || 'unknown',
    urgency: distraction.className.includes('high') ? 'high' : 
             distraction.className.includes('medium') ? 'medium' : 'low'
    };
             analyticsSystem.trackMiss(distractionType, 'timeout');

             triggerSilhouetteReaction('tear');
    if (gameState.lives <= 2) {
        audioManager.play('danger', 'warning');
    } else {
        audioManager.play('miss', 'normal');
    }

    // PHASE 3C: SCREEN SHAKE FOR MISSED DISTRACTIONS
    if (gameState.lives <= 1) {
        screenShake.intense(); // Last life - dramatic shake
        console.log('📳 CRITICAL: Last life shake triggered');
    } else if (gameState.lives <= 2) {
        screenShake.danger(); // Low health - danger shake
        console.log('📳 WARNING: Danger shake triggered');
    } else {
        screenShake.subtle(); // Normal miss - subtle feedback
        console.log('📳 Miss shake triggered');
    }
    
    if (gameState.lives === 2) { 
        showGameplayMessage('Careful!', 'Only 2 hearts left'); 
    } else if (gameState.lives === 1) { 
        showGameplayMessage('Last chance!', 'One heart remaining'); 
    }
    
    distraction.remove();
    const index = gameState.distractions.indexOf(distraction);
    if (index > -1) {
        gameState.distractions.splice(index, 1);
    }
    
    checkGameCompletion();
}

function checkGameCompletion() {
    if (!gameState.gameRunning || gameState.gameEnding) {
        return;
    }
    
    const shouldEnd = gameState.lives <= 0;
    
    const gameTimeSeconds = (Date.now() - gameState.gameStartTime) / 1000;
    const accuracy = gameState.totalDistractions > 0 ? 
        ((gameState.eliminatedDistractions / gameState.totalDistractions) * 100).toFixed(1) : 0;
    
    console.log(`🔍 Endless mode check: Lives=${gameState.lives}, Time=${gameTimeSeconds.toFixed(1)}s, Score=${gameState.score}, Accuracy=${accuracy}%, ShouldEnd=${shouldEnd}`);
    
    if (shouldEnd) {
        endGame();
    }
}

function endGame() {
    if (gameState.gameEnding) {
        console.log('🛑 Game already ending, skipping duplicate call');
        return;
    }
    
    console.log('🏁 Ending game...');
    
    // Animation frame cleanup and reset movement counter
    if (gameState.animationFrame) { 
        cancelAnimationFrame(gameState.animationFrame); 
    }
    // Reset movement counter
    distractionMovement.currentMovingCount = 0;
    
    audioManager.play('gameOver', 'ending');

    // Stop background music when game ends
    audioManager.stopBackgroundMusic();
    console.log('🎵 Background music stopped for game end');

    // PHASE 3C: DRAMATIC GAME OVER SCREEN SHAKE
    screenShake.gameOver();
    console.log('📳 GAME OVER: Dramatic shake triggered');
    gameState.gameEnding = true;
    gameState.gameRunning = false;
    
    timerManager.clearAll();
    messageSystem.clearAll();
    gameState.cleanup();
    
    const playTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
    const accuracy = gameState.totalDistractions > 0 ? 
        ((gameState.eliminatedDistractions / gameState.totalDistractions) * 100).toFixed(1) : 0;

    // PHASE 3C: End analytics session and generate insights
    const sessionReport = analyticsSystem.endSession(gameState.score);

    let message = `Your embrace lasted ${playTime} seconds!\n`;
    message += `Accuracy: ${accuracy}% (${gameState.eliminatedDistractions}/${gameState.totalDistractions})\n`;

    if (gameState.score >= 500) {
        message += "LEGENDARY performance! Master of Focus! 🏆";
    } else if (gameState.score >= 200) {
        message += "Excellent focus! You're getting stronger! 💪";
    } else if (gameState.score >= 100) {
        message += "Great improvement! Keep practicing! 📈";
    } else {
        message += "Every master started as a beginner! 🌟";
    }
    
    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('performanceMessage').textContent = message;
    
    setTimeout(() => {
        showScreen('resultsScreen');
        generateQRCode();
        console.log('✅ Game ended successfully');
    }, 1000);
}

function updateHUD() {
    document.getElementById('score').textContent = gameState.score;
    
    const hearts = document.querySelectorAll('.heart');
    hearts.forEach((heart, index) => {
        if (index < gameState.lives) {
            heart.classList.add('active');
            heart.classList.remove('inactive');
        } else {
            heart.classList.remove('active');
            heart.classList.add('inactive');
        }
    });
}

function updateProgressiveSilhouette(score) {
    const newLevel = progressiveSilhouettes
        .filter(s => score >= s.threshold)
        .pop();
    
    if (newLevel && newLevel.level > gameState.currentSilhouetteLevel) {
        console.log(`🎭 SILHOUETTE PROGRESSION: Level ${gameState.currentSilhouetteLevel} → ${newLevel.level}`);
        console.log(`✨ Milestone: ${newLevel.name}`);
        
        gameState.currentSilhouetteLevel = newLevel.level;
        updateCoupleSilhouette(newLevel.url);
        showMilestoneNotification(newLevel);
        
        // Trigger Three.js milestone effect
        threeManager.onMilestoneReached(newLevel);
    }
}

function updateCoupleSilhouette(imageUrl) {
    const silhouetteContainer = document.getElementById('coupleSilhouette');
    const silhouetteImage = document.getElementById('silhouetteImage');
    
    if (!silhouetteContainer || !silhouetteImage || !imageUrl) {
        console.log('⚠️ Silhouette elements not found');
        return;
    }
    
    console.log(`🎭 Smooth silhouette transition to: ${imageUrl}`);
    
    silhouetteContainer.classList.add('transitioning');
    silhouetteContainer.classList.add('silhouette-fade-out');
    
    setTimeout(() => {
        silhouetteImage.src = imageUrl;
        
        // 💔 UPDATE TEAR OVERLAY WITH NEW IMAGE
        const tearOverlay = silhouetteContainer.querySelector('.tear-overlay');
        if (tearOverlay) {
            const tearHalves = tearOverlay.querySelectorAll('.tear-half');
            tearHalves.forEach(half => {
                half.style.backgroundImage = `url(${imageUrl})`;
            });
            console.log('🔄 Tear overlay synced with new silhouette');
        }
        
        silhouetteContainer.classList.remove('silhouette-fade-out');
        
        setTimeout(() => {
            silhouetteContainer.classList.add('silhouette-fade-in');
            
            setTimeout(() => {
                silhouetteContainer.classList.remove('transitioning', 'silhouette-fade-in');
                silhouetteContainer.style.display = 'block';
                silhouetteContainer.style.opacity = '0.8';
                
                // Clean up any existing body-level tear effects when silhouette changes
                const existingTear = document.getElementById('bodyTearEffect');
                if (existingTear) {
                    existingTear.remove();
                    console.log('🧹 Cleaned up body-level tear effect during silhouette change');
                }
                
                console.log(`✅ Smooth silhouette transition complete: ${imageUrl}`);
            }, 400);
            
        }, 50);
        
    }, 300);
}

// ========================================================================
// SMART TOP MESSAGE SYSTEM WITH PROPER CLEANUP
// ========================================================================
const messageSystem = {
    activeMessages: new Set(),
    messageQueue: [],
    isProcessing: false,
    
    settings: {
        topPosition: 120,
        mobileTopPosition: 110,
        maxWidth: 260,
        displayDuration: 2500,
        queueDelay: 800,
        maxConcurrent: 1
    },
    
    clearAll() {
        console.log('🧹 Clearing all game messages...');
        
        const allMessages = document.querySelectorAll('.game-message');
        allMessages.forEach(msg => {
            if (msg.parentNode) {
                msg.remove();
            }
        });
        
        this.activeMessages.clear();
        this.messageQueue = [];
        this.isProcessing = false;
        
        console.log('✅ All messages cleared');
    },
    
    showMessage(content, type = 'info', duration = null) {
        const message = {
            content,
            type,
            duration: duration || this.settings.displayDuration,
            id: Date.now() + Math.random()
        };
        
        if (this.activeMessages.size >= this.settings.maxConcurrent) {
            this.messageQueue.push(message);
            console.log(`📝 Message queued: ${content.substring(0, 30)}...`);
        } else {
            this.displayMessage(message);
        }
    },
    
    displayMessage(message) {
        const messageEl = document.createElement('div');
        messageEl.className = `game-message ${message.type}`;
        messageEl.innerHTML = message.content;
        messageEl.dataset.messageId = message.id;
        
        const isMobile = window.innerWidth <= 768;
        messageEl.style.top = (isMobile ? this.settings.mobileTopPosition : this.settings.topPosition) + 'px';
        messageEl.style.width = this.settings.maxWidth + 'px';
        
        document.body.appendChild(messageEl);
        this.activeMessages.add(message.id);
        
        console.log(`📢 Showing top message: ${message.content.substring(0, 30)}...`);
        
        const timeoutId = setTimeout(() => {
            this.removeMessage(message.id);
        }, message.duration);
        
        timerManager.addTimeout(timeoutId);
    },
    
    removeMessage(messageId) {
        const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageEl && messageEl.parentNode) {
            messageEl.remove();
        }
        
        this.activeMessages.delete(messageId);
        
        if (this.messageQueue.length > 0 && this.activeMessages.size < this.settings.maxConcurrent) {
            const delayId = setTimeout(() => {
                const nextMessage = this.messageQueue.shift();
                if (nextMessage) {
                    this.displayMessage(nextMessage);
                }
            }, this.settings.queueDelay);
            
            timerManager.addTimeout(delayId);
        }
    }
};

function showMilestoneNotification(milestone) {
    const content = `
        <div style="color: #FFD700; font-size: 1.1rem; font-weight: 600;">
            🎉 ${milestone.name}!
        </div>
        <div style="color: #fff; font-size: 0.85rem; margin-top: 4px; opacity: 0.9;">
            Level ${milestone.level} Unlocked
        </div>
    `;
    
    messageSystem.showMessage(content, 'milestone', 3000);
    audioManager.play('milestone', 'achievement');
    particleSystem.createMilestoneCelebration();

    // PHASE 3C: MILESTONE SCREEN SHAKE - CELEBRATION FEEDBACK
    screenShake.milestone();
    console.log(`📳 Milestone celebration shake: ${milestone.name}`);
    
    console.log(`🏆 Milestone message: ${milestone.name}`);
}

function showComboMessage(combo, points) {
    if (combo < 2) return;
    
    const content = `
        <div style="color: #ff6b6b; font-size: 0.8rem; font-weight: 600; margin-bottom: 2px;">
            🔥 ${combo}x COMBO!
        </div>
        <div style="color: #fff; font-size: 0.65rem;">
            +${points} points
        </div>
    `;
    
    messageSystem.showMessage(content, 'combo', 2000);
}

function showAchievementMessage(text, subtext = '') {
    const content = `
        <div style="color: #44ff88; font-size: 0.8rem; font-weight: 600; margin-bottom: 2px;">
            ⭐ ${text}
        </div>
        ${subtext ? `<div style="color: #fff; font-size: 0.65rem;">${subtext}</div>` : ''}
    `;
    
    messageSystem.showMessage(content, 'achievement', 2500);
}

function showGameplayMessage(text, subtext = '') {
    const content = `
        <div style="color: #87CEEB; font-size: 0.75rem; font-weight: 500; margin-bottom: 2px;">
            ${text}
        </div>
        ${subtext ? `<div style="color: #fff; font-size: 0.6rem; opacity: 0.8;">${subtext}</div>` : ''}
    `;
    
    messageSystem.showMessage(content, 'info', 2000);
}

function triggerSilhouetteReaction(type = 'safe') {
    const silhouette = document.getElementById('coupleSilhouette');
    if (!silhouette) return;
    
    console.log(`💔 Silhouette reaction triggered: ${type}`);
    
    // Clear any existing reaction classes
    silhouette.classList.remove('reaction-safe', 'reaction-danger', 'tearing', 'restoring');
    
    if (type === 'tear') {
        console.log('💔 Starting body-level diagonal tear...');
        
        // Setup tear data
        const tearData = setupTearOverlay(silhouette);
        if (!tearData) return;
        
        // Execute body-level tear effect
        executeBodyLevelTear(tearData);
        
        // Audio feedback
        if (typeof audioManager !== 'undefined') {
            audioManager.play('danger', 'tear-effect');
        }
        
    } else {
        // EXISTING REACTION TYPES (unchanged)
        const reactionClass = `reaction-${type}`;
        silhouette.classList.add(reactionClass);
        console.log(`✅ Applied class: ${reactionClass}`);
        
        setTimeout(() => {
            silhouette.classList.remove(reactionClass);
        }, 600);
    }
}

// ========================================================================
// STATE-MANAGED TEAR EXECUTION - PREVENTS DUPLICATES
// ========================================================================
const tearStateManager = {
    isExecuting: false,
    currentTearId: null,
    lastTearTime: 0,
    cooldownPeriod: 1000, // 1 second cooldown between tears
    
    canExecute() {
        const now = Date.now();
        const timeSinceLastTear = now - this.lastTearTime;
        
        if (this.isExecuting) {
            console.log('⚠️ Tear still executing - blocking duplicate');
            return false;
        }
        
        if (timeSinceLastTear < this.cooldownPeriod) {
            console.log(`⏰ Tear cooldown active - ${this.cooldownPeriod - timeSinceLastTear}ms remaining`);
            return false;
        }
        
        return true;
    },
    
    startExecution(tearId) {
        this.isExecuting = true;
        this.currentTearId = tearId;
        this.lastTearTime = Date.now();
        tearCleanupManager.registerTear(tearId);
        console.log(`🎬 Starting tear execution: ${tearId}`);
    },
    
    endExecution() {
        if (this.currentTearId) {
            tearCleanupManager.unregisterTear(this.currentTearId);
        }
        this.isExecuting = false;
        this.currentTearId = null;
        console.log('🏁 Tear execution completed');
    }
};

function executeBodyLevelTear(tearData) {
    // PREVENT DUPLICATE EXECUTION
    if (!tearStateManager.canExecute()) {
        console.warn('⚠️ Tear already executing - ignoring duplicate request');
        return;
    }
    
    const { imageElement, imageSrc, container } = tearData;
    const tearId = `tear_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // START STATE MANAGEMENT
    tearStateManager.startExecution(tearId);
    
    // Get current position of silhouette image
    const imageRect = imageElement.getBoundingClientRect();
    
    // Progressive tear intensity based on lives
    const currentLives = gameState.lives || 5;
    const tearIntensity = getTearIntensity(currentLives);
    
    console.log(`📍 Creating JAGGED TEAR ${tearId} at position: ${imageRect.left}, ${imageRect.top}`);
    console.log(`💔 Tear intensity: ${tearIntensity.name} (${currentLives} lives remaining)`);
    
    // Create tear container directly on body
    const tearContainer = document.createElement('div');
    tearContainer.id = tearId; // Use unique ID
    tearContainer.className = 'bodyTearEffect';
    tearContainer.style.cssText = `
        position: fixed;
        top: ${imageRect.top}px;
        left: ${imageRect.left}px;
        width: ${imageRect.width}px;
        height: ${imageRect.height}px;
        z-index: 999;
        pointer-events: none;
        opacity: 1;
    `;
    
    // JAGGED TEAR PATTERN (irregular tear line)
    const jaggedLeftClip = `polygon(0% 0%, 45% 0%, 43% 15%, 47% 30%, 41% 45%, 49% 60%, 44% 75%, 46% 90%, 42% 100%, 0% 100%)`;
    const jaggedRightClip = `polygon(58% 0%, 100% 0%, 100% 100%, 54% 100%, 56% 90%, 52% 75%, 57% 60%, 51% 45%, 55% 30%, 49% 15%, 53% 0%)`;
    
    // LEFT HALF - with jagged clip-path
    const leftHalf = document.createElement('div');
    leftHalf.className = 'tear-half left-half';
    leftHalf.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url(${imageSrc});
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        clip-path: ${jaggedLeftClip};
        transition: all ${tearIntensity.transitionSpeed}s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        transform: translate(0, 0) rotate(0deg);
        filter: drop-shadow(3px 0 10px rgba(0, 0, 0, 0.5));
    `;
    
    // RIGHT HALF - with jagged clip-path
    const rightHalf = document.createElement('div');
    rightHalf.className = 'tear-half right-half';
    rightHalf.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url(${imageSrc});
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        clip-path: ${jaggedRightClip};
        transition: all ${tearIntensity.transitionSpeed}s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        transform: translate(0, 0) rotate(0deg);
        filter: drop-shadow(-3px 0 10px rgba(0, 0, 0, 0.5));
    `;
    
    tearContainer.appendChild(leftHalf);
    tearContainer.appendChild(rightHalf);
    document.body.appendChild(tearContainer);
    
    console.log(`💥 Phase 1: JAGGED TEAR created (${tearIntensity.name} intensity)`);
    
    // Hide original image
    imageElement.style.opacity = '0';
    
    // ENHANCEMENT 2: Synchronized sound effects
    playTearSoundSequence(tearIntensity);
    
    // PHASE 2: Animate separation with progressive intensity
    setTimeout(() => {
        // VERIFY TEAR STILL EXISTS (prevents race conditions)
        if (!document.getElementById(tearId)) {
            console.warn('⚠️ Tear removed before animation - aborting');
            tearStateManager.endExecution();
            return;
        }
        
        leftHalf.style.transform = `translate(-${tearIntensity.separation}px, 0) rotate(-${tearIntensity.rotation}deg)`;
        leftHalf.style.filter = `brightness(${tearIntensity.brightness}) drop-shadow(8px 0 15px rgba(0, 0, 0, 0.7))`;
        
        rightHalf.style.transform = `translate(${tearIntensity.separation}px, 0) rotate(${tearIntensity.rotation}deg)`;
        rightHalf.style.filter = `brightness(${tearIntensity.brightness}) drop-shadow(-8px 0 15px rgba(0, 0, 0, 0.7))`;
        
        // ENHANCEMENT 3: Particle effects during separation
        createTearParticleEffects(imageRect, tearIntensity);
        
        console.log(`💥 Phase 2: JAGGED TEAR separation - ${tearIntensity.separation}px gap, ${tearIntensity.rotation}° rotation!`);
    }, 50);
    
    // PHASE 3: FASTER Restoration - WITH STATE CHECK
    setTimeout(() => {
        // VERIFY TEAR STILL EXISTS
        if (!document.getElementById(tearId)) {
            console.warn('⚠️ Tear removed before restoration - aborting');
            tearStateManager.endExecution();
            return;
        }
        
        console.log('💚 Phase 3: Starting FAST jagged tear restoration...');
        
        leftHalf.style.transform = 'translate(0, 0) rotate(0deg)';
        leftHalf.style.filter = 'brightness(1) drop-shadow(3px 0 10px rgba(0, 0, 0, 0.5))';
        
        rightHalf.style.transform = 'translate(0, 0) rotate(0deg)';
        rightHalf.style.filter = 'brightness(1) drop-shadow(-3px 0 10px rgba(0, 0, 0, 0.5))';
        
        // Faster restoration timing
        setTimeout(() => {
            // FINAL STATE CHECK
            if (document.getElementById(tearId)) {
                imageElement.style.opacity = '0.8';
                tearContainer.remove();
                console.log('✅ Phase 4: FAST jagged tear restoration completed');
            }
            
            // END STATE MANAGEMENT
            tearStateManager.endExecution();
        }, tearIntensity.restorationSpeed);
        
    }, tearIntensity.separationDuration);
}

// ========================================================================
// ENHANCEMENT 4: PROGRESSIVE TEAR INTENSITY BASED ON LIVES
// ========================================================================
function getTearIntensity(livesRemaining) {
    const intensityLevels = {
        5: {
            name: "Gentle Crack",
            separation: 10,          // REDUCED: was 25, now 10 (24px total)
            rotation: 6,             // UNCHANGED
            brightness: 0.95,        // UNCHANGED
            transitionSpeed: 0.6,    // UNCHANGED
            separationDuration: 800, // UNCHANGED
            restorationSpeed: 400,   // UNCHANGED
            particleCount: 8,        // UNCHANGED
            soundIntensity: 'low'    // UNCHANGED
        },
        4: {
            name: "Growing Strain",
            separation: 12,          // REDUCED: was 35, now 12 (36px total)
            rotation: 8,             // UNCHANGED
            brightness: 0.92,        // UNCHANGED
            transitionSpeed: 0.7,    // UNCHANGED
            separationDuration: 900, // UNCHANGED
            restorationSpeed: 450,   // UNCHANGED
            particleCount: 12,       // UNCHANGED
            soundIntensity: 'low'    // UNCHANGED
        },
        3: {
            name: "Serious Tear",
            separation: 15,          // REDUCED: was 45, now 15 (44px total)
            rotation: 12,            // UNCHANGED
            brightness: 0.88,        // UNCHANGED
            transitionSpeed: 0.8,    // UNCHANGED
            separationDuration: 1000,// UNCHANGED
            restorationSpeed: 500,   // UNCHANGED
            particleCount: 16,       // UNCHANGED
            soundIntensity: 'medium' // UNCHANGED
        },
        2: {
            name: "Critical Break",
            separation: 20,          // REDUCED: was 60, now 20 (60px total)
            rotation: 16,            // UNCHANGED
            brightness: 0.82,        // UNCHANGED
            transitionSpeed: 0.9,    // UNCHANGED
            separationDuration: 1200,// UNCHANGED
            restorationSpeed: 550,   // UNCHANGED
            particleCount: 20,       // UNCHANGED
            soundIntensity: 'high'   // UNCHANGED
        },
        1: {
            name: "Relationship Crisis",
            separation: 25,          // REDUCED: was 80, now 25 (80px total)
            rotation: 22,            // UNCHANGED
            brightness: 0.75,        // UNCHANGED
            transitionSpeed: 1.0,    // UNCHANGED
            separationDuration: 1400,// UNCHANGED
            restorationSpeed: 600,   // UNCHANGED
            particleCount: 28,       // UNCHANGED
            soundIntensity: 'critical'// UNCHANGED
        },
        0: {
            name: "Complete Devastation",
            separation: 35,          // REDUCED: was 100, now 35 (100px total)
            rotation: 30,            // UNCHANGED
            brightness: 0.65,        // UNCHANGED
            transitionSpeed: 1.2,    // UNCHANGED
            separationDuration: 1600,// UNCHANGED
            restorationSpeed: 700,   // UNCHANGED
            particleCount: 35,       // UNCHANGED
            soundIntensity: 'critical'// UNCHANGED
        }
    };
    
    return intensityLevels[Math.max(0, livesRemaining)] || intensityLevels[0];
}

// ========================================================================
// BODY-LEVEL TEAR EFFECT SETUP - BYPASSES CSS CONFLICTS
// ========================================================================
function setupTearOverlay(silhouetteContainer) {
    // Clean up any existing tear effects
    const existingTear = document.getElementById('bodyTearEffect');
    if (existingTear) {
        existingTear.remove();
    }
    
    console.log('🔧 Creating body-level tear effect...');
    
    const silhouetteImage = silhouetteContainer.querySelector('img');
    if (!silhouetteImage) {
        console.warn('⚠️ No silhouette image found for tear effect');
        return null;
    }
    
    // Store image source for later use
    const currentImageSrc = silhouetteImage.src;
    
    // Return a setup object for the tear effect
    return {
        imageElement: silhouetteImage,
        imageSrc: currentImageSrc,
        container: silhouetteContainer,
        isBodyLevel: true
    };
}

function restartGame() {
    console.log('🔄 Restarting game...');
    
    timerManager.clearAll();
    messageSystem.clearAll();
    
    // Clean up Three.js
    threeManager.destroy();
    
    gameState.reset();
    
    setTimeout(() => {
        startGame();
    }, 100);
}

function toggleAudio() {
    gameState.audioEnabled = !gameState.audioEnabled;
    
    if (audioManager) {
        audioManager.settings.enableSFX = gameState.audioEnabled;
    }
    
    document.getElementById('audioIcon').textContent = gameState.audioEnabled ? '🔊' : '🔇';
    console.log(`🔊 Audio ${gameState.audioEnabled ? 'enabled' : 'disabled'}`);
    
    if (gameState.audioEnabled && audioManager) {
        setTimeout(() => audioManager.play('eliminate'), 100);
    }
}

// ========================================================================
// TEAR SOUND EFFECTS USING AVAILABLE SOUNDS
// ========================================================================
function playTearSoundSequence(tearIntensity) {
    console.log(`🎵 Playing ${tearIntensity.soundIntensity} intensity tear sounds`);
    
    // Initial tear sound (immediate) - using confirmed available sounds
    if (typeof audioManager !== 'undefined' && audioManager.sounds) {
        switch (tearIntensity.soundIntensity) {
            case 'low':
                // Gentle tear - use miss sound (soft)
                audioManager.play('miss', 'gentle-tear');
                break;
            case 'medium':
                // Moderate tear - use danger sound 
                audioManager.play('danger', 'moderate-tear');
                setTimeout(() => audioManager.play('swoosh', 'tear-echo'), 150);
                break;
            case 'high':
                // Serious tear - use danger + eliminate
                audioManager.play('danger', 'serious-tear');
                setTimeout(() => audioManager.play('eliminate', 'tear-impact'), 150);
                break;
            case 'critical':
                // Critical tear - use multiple intense sounds
                audioManager.play('danger', 'critical-tear');
                setTimeout(() => audioManager.play('gameOver', 'devastation'), 100);
                setTimeout(() => audioManager.play('eliminate', 'heartbreak'), 300);
                break;
        }
    }
    
    // Restoration sound (played during healing) - using confirmed sounds
    setTimeout(() => {
        if (typeof audioManager !== 'undefined' && audioManager.sounds) {
            if (tearIntensity.soundIntensity === 'critical') {
                audioManager.play('milestone', 'healing-hope');
            } else {
                audioManager.play('levelUp', 'gentle-healing');
            }
        }
        console.log('🎵 Healing sound played');
    }, tearIntensity.separationDuration - 200);
}

// ========================================================================
// TEAR PARTICLE EFFECTS 
// ========================================================================
function createTearParticleEffects(imageRect, tearIntensity) {
    if (typeof particleSystem === 'undefined' || !particleSystem.createBurst) {
        console.log('⚠️ Particle system not available for tear effects');
        return;
    }
    
    // PERFORMANCE OPTIMIZATION: Reduce particles on mobile
    const isMobile = gameState.isMobile || window.innerWidth <= 768;
    const optimizedParticleCount = isMobile ? 
        Math.floor(tearIntensity.particleCount * 0.6) : 
        tearIntensity.particleCount;
    
    // FIX: Ensure minimum particles per burst (prevent 0 particles)
    const particlesPerBurst = Math.max(2, Math.ceil(optimizedParticleCount / 5));
    
    console.log(`✨ Creating ${optimizedParticleCount} particles (${particlesPerBurst} per burst, ${isMobile ? 'mobile' : 'desktop'})`);
    
    // Center of the tear (where the split happens)
    const tearCenterX = imageRect.left + (imageRect.width / 2);
    const tearCenterY = imageRect.top + (imageRect.height / 2);
    
    // Create multiple particle bursts along the tear line
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            const offsetY = (i - 2) * (imageRect.height / 6);
            const burstX = tearCenterX + (Math.random() - 0.5) * 20;
            const burstY = tearCenterY + offsetY;
            
            // Different colors based on intensity
            let particleColor;
            switch (tearIntensity.soundIntensity) {
                case 'low':
                    particleColor = '#ffd700'; // Gold
                    break;
                case 'medium':
                    particleColor = '#ffa500'; // Orange
                    break;
                case 'high':
                    particleColor = '#ff6b6b'; // Red
                    break;
                case 'critical':
                    particleColor = '#8b0000'; // Dark red
                    break;
                default:
                    particleColor = '#ffffff'; // White
            }
            
            // Create particle burst with guaranteed minimum particles
            particleSystem.createBurst(burstX, burstY, particleColor, particlesPerBurst);
            
            console.log(`✨ Burst ${i + 1}: ${particlesPerBurst} particles at (${burstX.toFixed(1)}, ${burstY.toFixed(1)})`);
        }, i * 50);
    }
    
    // Special critical intensity effect with guaranteed particles
    if (tearIntensity.soundIntensity === 'critical') {
        setTimeout(() => {
            const criticalParticles = isMobile ? 12 : 20; // Mobile optimization
            particleSystem.createBurst(tearCenterX, tearCenterY, '#ff0000', criticalParticles);
            console.log(`💥 CRITICAL EXPLOSION: ${criticalParticles} particles!`);
        }, 200);
    }
}

// ========================================================================
// CLEANUP SYSTEM - PREVENTING DOM POLLUTION
// ========================================================================
const tearCleanupManager = {
    activeTears: new Set(),
    
    registerTear(tearId) {
        this.activeTears.add(tearId);
        console.log(`📝 Registered tear: ${tearId} (${this.activeTears.size} active)`);
    },
    
    unregisterTear(tearId) {
        this.activeTears.delete(tearId);
        console.log(`✅ Unregistered tear: ${tearId} (${this.activeTears.size} remaining)`);
    },
    
    forceCleanupAll() {
        console.log('🧹 FORCE CLEANUP: Removing all tear effects...');
        
        // Remove all tear-related elements
        const tearElements = document.querySelectorAll(`
            [id*="tearEffect"], 
            [id*="bodyTear"], 
            .tear-overlay, 
            .tear-half,
            .left-half,
            .right-half
        `);
        
        tearElements.forEach((el, index) => {
            el.remove();
            console.log(`🗑️ Removed element ${index + 1}: ${el.tagName}${el.id ? '#' + el.id : ''}${el.className ? '.' + el.className : ''}`);
        });
        
        // Clear active tear tracking
        this.activeTears.clear();
        
        console.log(`✅ Force cleanup completed: Removed ${tearElements.length} elements`);
        return tearElements.length;
    },
    
    verifyCleanup() {
        const remaining = document.querySelectorAll(`
            [id*="tearEffect"], 
            [id*="bodyTear"], 
            .tear-overlay, 
            .tear-half
        `);
        
        const isClean = remaining.length === 0 && this.activeTears.size === 0;
        
        console.log(`🔍 Cleanup verification:`);
        console.log(`  - DOM elements: ${remaining.length}`);
        console.log(`  - Tracked tears: ${this.activeTears.size}`);
        console.log(`  - Status: ${isClean ? '✅ CLEAN' : '❌ DIRTY'}`);
        
        if (!isClean) {
            console.warn('⚠️ Cleanup incomplete - triggering force cleanup');
            this.forceCleanupAll();
        }
        
        return isClean;
    }
};
// ========================================================================
// CLEANUP VERIFICATION AND PERFORMANCE MONITORING
// ========================================================================
function verifyTearCleanup() {
    const remainingTears = document.querySelectorAll('[id*="tearEffect"], [id*="bodyTear"]');
    const remainingOverlays = document.querySelectorAll('.tear-overlay, .tear-half');
    
    console.log(`🧹 Cleanup verification:`);
    console.log(`  - Tear containers: ${remainingTears.length}`);
    console.log(`  - Tear overlays: ${remainingOverlays.length}`);
    
    if (remainingTears.length > 0 || remainingOverlays.length > 0) {
        console.warn('⚠️ Cleanup incomplete - forcing removal');
        remainingTears.forEach(el => el.remove());
        remainingOverlays.forEach(el => el.remove());
    }
    
    return remainingTears.length === 0 && remainingOverlays.length === 0;
}

// ========================================================================
// QR CODE SYSTEM
// ========================================================================
function generateQRCode() {
    try {
        console.log("📱 Generating QR code...");
        
        const qrDiv = document.getElementById('qrCode');
        if (!qrDiv || typeof QRious === 'undefined') {
            console.log("❌ QR code generation failed - missing elements");
            return;
        }
        
        qrDiv.innerHTML = '';
        const canvas = document.createElement('canvas');
        qrDiv.appendChild(canvas);
        
        new QRious({
            element: canvas,
            value: `https://blinkit.com/prn/kamasutra-longlast-condom/prid/25756?ref=endless-embrace&score=${gameState.score}`,
            size: 130,
            background: '#ffffff',
            foreground: '#000000',
            level: 'H'
        });
        
        console.log("✅ QR code generated successfully");
    } catch (error) {
        console.error('❌ QR Code generation failed:', error);
    }
}

function saveQRCode() {
    try {
        const canvas = document.querySelector('#qrCode canvas');
        if (canvas) {
            const link = document.createElement('a');
            link.download = `ks-endless-embrace-score-${gameState.score}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            console.log("✅ QR code saved");
        }
    } catch (error) {
        console.error('❌ QR Code save failed:', error);
    }
}


// ========================================================================
// COUPLE CHALLENGE SYSTEM
// ========================================================================

function displayCoupleResults(player1, player2) {
    try {
        const metrics = calculateCoupleMetrics(player1, player2);
        
        const elements = {
            yourScore: document.getElementById('yourScore'),
            partnerScore: document.getElementById('partnerScore'),
            totalScore: document.getElementById('totalScore'),
            harmonyLevel: document.getElementById('harmonyLevel'),
            combinedTime: document.getElementById('combinedTime'),
            coupleResults: document.getElementById('coupleResults')
        };
        
        if (elements.yourScore) elements.yourScore.textContent = player1.score;
        if (elements.partnerScore) elements.partnerScore.textContent = player2.score;
        if (elements.totalScore) elements.totalScore.textContent = metrics.totalScore;
        if (elements.harmonyLevel) elements.harmonyLevel.textContent = metrics.harmonyLevel;
        if (elements.combinedTime) elements.combinedTime.textContent = metrics.combinedTime + 's';
        if (elements.coupleResults) elements.coupleResults.style.display = 'block';
        
        checkCoupleAchievements(metrics, player1, player2);
        
        console.log('💕 Couple results displayed successfully');
    } catch (error) {
        console.error('❌ Couple results display failed:', error);
    }
}

function calculateCoupleMetrics(player1Data, player2Data) {
    const totalScore = player1Data.score + player2Data.score;
    const averageScore = (player1Data.score + player2Data.score) / 2;
    const combinedTime = player1Data.time + player2Data.time;
    const scoreDifference = Math.abs(player1Data.score - player2Data.score);
    const harmonyLevel = calculateHarmony(player1Data.score, player2Data.score);
    
    // Safety check for achievements arrays
    const player1Achievements = player1Data.achievements || [];
    const player2Achievements = player2Data.achievements || [];
    const sharedAchievements = player1Achievements.filter(a => 
        player2Achievements.includes(a));
    
    return {
        totalScore,
        averageScore,
        combinedTime,
        scoreDifference,
        harmonyLevel,
        sharedAchievements,
        leader: player1Data.score > player2Data.score ? 'You' : 'Partner',
        winMargin: Math.abs(player1Data.score - player2Data.score)
    };
}

function calculateHarmony(score1, score2) {
    // Safety check for valid scores
    if (typeof score1 !== 'number' || typeof score2 !== 'number') {
        return "Unknown Connection 🤔";
    }
    
    const difference = Math.abs(score1 - score2);
    const average = (score1 + score2) / 2;
    
    // Prevent division by zero
    if (average === 0) {
        return "Starting Together 😊";
    }
    
    const harmonyPercentage = Math.max(0, 100 - (difference / average * 100));
    
    if (harmonyPercentage >= 90) return "Perfect Harmony ❤️";
    if (harmonyPercentage >= 75) return "Great Sync 💕";
    if (harmonyPercentage >= 60) return "Good Connection 😊";
    if (harmonyPercentage >= 40) return "Room to Improve 🤔";
    return "Opposites Attract? 😅";
}

function checkCoupleAchievements(metrics, player1, player2) {
    try {
        // Safety check for coupleAchievements data
        if (typeof coupleAchievements === 'undefined') {
            console.warn('⚠️ Couple achievements data not loaded');
            return [];
        }
        
        const unlockedAchievements = [];
        
        // Perfect Harmony - scores within 10% of each other
        if (metrics.scoreDifference <= metrics.averageScore * 0.1) {
            unlockedAchievements.push(coupleAchievements.perfectHarmony);
        }
        
        // Power Couple - combined score over 300
        if (metrics.totalScore > 300) {
            unlockedAchievements.push(coupleAchievements.powerCouple);
        }
        
        // Marathon Lovers - combined time over 3 minutes (180 seconds)
        if (metrics.combinedTime > 180) {
            unlockedAchievements.push(coupleAchievements.marathonLovers);
        }
        
        // Synchronized Souls - 3+ shared achievements
        if (metrics.sharedAchievements.length >= 3) {
            unlockedAchievements.push(coupleAchievements.synchronizedSouls);
        }
        
        // Competitive Spirits - score difference over 100
        if (metrics.scoreDifference > 100) {
            unlockedAchievements.push(coupleAchievements.competitiveSpirits);
        }
        
        // Twin Flames - identical scores
        if (player1.score === player2.score) {
            unlockedAchievements.push(coupleAchievements.twinFlames);
        }
        
        // Display achievements with proper timer management
        if (unlockedAchievements.length > 0) {
            const timeoutId = timerManager.addTimeout(setTimeout(() => {
                unlockedAchievements.forEach((achievement, index) => {
                    const innerTimeoutId = timerManager.addTimeout(setTimeout(() => {
                        // Use existing achievement message system
                        if (typeof showAchievementMessage !== 'undefined') {
                            showAchievementMessage(achievement.name, achievement.description);
                        } else {
                            // Fallback to game message system
                            showGameplayMessage(`🏆 ${achievement.icon} ${achievement.name}`, achievement.description);
                        }
                        console.log(`🏆 Couple achievement unlocked: ${achievement.name}`);
                    }, index * 1500));
                });
            }, 500));
        }
        
        return unlockedAchievements;
    } catch (error) {
        console.error('❌ Couple achievements check failed:', error);
        return [];
    }
}

// ========================================================================
// COUPLE CHALLENGE UI FUNCTIONS
// ========================================================================

function generateChallengeCode() {
    try {
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        gameState.challengeCode = code;
        
        const challengeCodeEl = document.getElementById('challengeCode');
        if (challengeCodeEl) {
            challengeCodeEl.textContent = code;
        }
        
        const challengeData = {
            code: code,
            score: gameState.score,
            time: gameState.gameStartTime ? Math.floor((Date.now() - gameState.gameStartTime) / 1000) : 0,
            achievements: gameState.achievements || [],
            lives: gameState.lives,
            perfectRounds: gameState.perfectRounds || 0,
            timestamp: Date.now()
        };
        
        localStorage.setItem('challenge_' + code, JSON.stringify(challengeData));
        updateChallengeStatus('Challenge created! Share this code with your partner.');
        
        console.log('🎯 Challenge code generated and saved:', code);
        
    } catch (error) {
        console.error('❌ Challenge code generation failed:', error);
    }
}

function showEnterCode() {
    try {
        const code = prompt('Enter your partner\'s challenge code:');
        if (code && code.trim()) {
            const cleanCode = code.trim();
            
            if (cleanCode.length === 6 && /^\d{6}$/.test(cleanCode)) {
                enterChallengeCode(cleanCode);
            } else {
                alert('Please enter a valid 6-digit challenge code.');
                console.log('⚠️ Invalid code format entered:', cleanCode);
            }
        }
    } catch (error) {
        console.error('❌ Enter code failed:', error);
    }
}

function enterChallengeCode(code) {
    try {
        const partnerData = localStorage.getItem('challenge_' + code);
        if (partnerData) {
            const partner = JSON.parse(partnerData);
            
            const timeSince = Date.now() - partner.timestamp;
            if (timeSince > 86400000) {
                alert('This challenge code has expired. Please get a new one from your partner.');
                updateChallengeStatus('Challenge code expired. Please get a new code.');
                return;
            }
            
            const yourData = {
                score: gameState.score,
                time: gameState.gameStartTime ? Math.floor((Date.now() - gameState.gameStartTime) / 1000) : 0,
                achievements: gameState.achievements || []
            };
            
            updateChallengeStatus('Partner found! Calculating couple results...');
            
            const timeoutId = timerManager.addTimeout(setTimeout(() => {
                displayCoupleResults(yourData, partner);
                console.log('💕 Couple results displayed for codes:', gameState.challengeCode, 'vs', code);
            }, 1000));
            
        } else {
            alert('Invalid challenge code. Please check and try again.');
            updateChallengeStatus('Invalid challenge code entered.');
            console.log('⚠️ Challenge code not found:', code);
        }
    } catch (error) {
        console.error('❌ Challenge code processing failed:', error);
        alert('Error processing challenge code.');
        updateChallengeStatus('Error processing challenge code.');
    }
}

function updateChallengeStatus(message) {
    try {
        const statusElement = document.getElementById('coupleStatus');
        const textElement = document.getElementById('challengeStatusText');
        
        if (statusElement && textElement) {
            textElement.textContent = message;
            statusElement.style.display = 'block';
            
            // Auto-hide after 5 seconds
            const timeoutId = timerManager.addTimeout(setTimeout(() => {
                statusElement.style.display = 'none';
            }, 5000));
        }
    } catch (error) {
        console.error('❌ Challenge status update failed:', error);
    }
}

// ========================================================================
// COUPLE CHALLENGE DATA STORAGE
// ========================================================================

function saveCoupleSession(sessionData) {
    try {
        localStorage.setItem('coupleChallenge_session', JSON.stringify(sessionData));
        console.log('💾 Couple session saved');
    } catch (error) {
        console.error('❌ Couple session save failed:', error);
    }
}

function loadCoupleSession() {
    try {
        const saved = localStorage.getItem('coupleChallenge_session');
        if (saved) {
            return JSON.parse(saved);
        }
        return null;
    } catch (error) {
        console.error('❌ Couple session load failed:', error);
        return null;
    }
}

// ========================================================================
// WHATSAPP SHARING SYSTEM
// ========================================================================
function shareWhatsApp() {
    try {
        // Safety check for data arrays
        if (typeof hinglishTemplates === 'undefined' || typeof coupleSharingTemplates === 'undefined') {
            console.warn('⚠️ Sharing templates not loaded, using fallback');
            // Fallback to simple sharing
            const message = `I scored ${gameState.score} points in KamaSutra Endless Embrace! 🎮 Can you beat my score? 😎`;
            const url = `https://wa.me/?text=${encodeURIComponent(message + '\n\nPlay here: ' + window.location.href)}`;
            window.open(url, '_blank');
            return;
        }
        
        let message;
        
        const coupleResults = document.getElementById('coupleResults');
        if (coupleResults && coupleResults.style.display !== 'none') {
            // Couple sharing logic
            const template = coupleSharingTemplates[Math.floor(Math.random() * coupleSharingTemplates.length)];
            const totalScore = document.getElementById('totalScore')?.textContent || '0';
            const harmonyLevel = document.getElementById('harmonyLevel')?.textContent || 'Unknown';
            const combinedTime = document.getElementById('combinedTime')?.textContent.replace('s', '') || '0';
            
            message = template
                .replace('{totalScore}', totalScore)
                .replace('{harmonyLevel}', harmonyLevel)
                .replace('{combinedTime}', combinedTime)
                .replace('{challengeCode}', gameState.challengeCode || '');
        } else {
            // Individual sharing with Hinglish templates
            const template = hinglishTemplates[Math.floor(Math.random() * hinglishTemplates.length)];
            const playTime = gameState.gameStartTime ? Math.floor((Date.now() - gameState.gameStartTime) / 1000) : 0;
            
            message = template
                .replace('{score}', gameState.score)
                .replace('{time}', playTime)
                .replace('{streak}', gameState.combo || 0);
        }
        
        const challengeParam = gameState.challengeCode ? `?challenge=${gameState.challengeCode}` : '';
        const url = `https://wa.me/?text=${encodeURIComponent(message + '\n\nPlay here: ' + window.location.href + challengeParam)}`;
        window.open(url, '_blank');
        
        console.log('📱 WhatsApp sharing initiated');
        
    } catch (error) {
        console.error('❌ WhatsApp sharing failed:', error);
        // Fallback - show alert with message
        if (typeof message !== 'undefined') {
            alert('Copy this message to share:\n\n' + message);
        }
    }
}

function setupEventListeners() {
    console.log('🎧 Setting up event listeners...');
    
    // Basic game event listeners
    document.addEventListener('click', function(e) {
        // Ensure audio context starts on first user interaction
        if (typeof audioManager !== 'undefined' && audioManager.ensureAudioContext) {
            audioManager.ensureAudioContext();
        }
    });
    
    // Keyboard event listeners
    document.addEventListener('keydown', function(e) {
        if (e.code === 'Space' && !gameState.gameRunning) {
            e.preventDefault();
            startGame();
        }
        if (e.code === 'Escape' && gameState.gameRunning) {
            e.preventDefault();
            endGame();
        }
    });
    
    // Window resize listener for responsive design
    window.addEventListener('resize', function() {
        gameState.isMobile = window.innerWidth <= 768;
        if (typeof distractionMovement !== 'undefined') {
            distractionMovement.maxMovingDistractions = gameState.isMobile ? 10 : 25;
        }
    });
    
    console.log('✅ Event listeners set up');
}

// ========================================================================
// INITIALIZATION
// ========================================================================
function init() {
    console.log('🎮 Initializing game...');
    
    // CREATE BACKGROUND CANVAS if it doesn't exist
    let bgCanvas = document.getElementById('backgroundCanvas');
    if (!bgCanvas) {
        bgCanvas = document.createElement('canvas');
        bgCanvas.id = 'backgroundCanvas';
        bgCanvas.style.position = 'absolute';
        bgCanvas.style.top = '0';
        bgCanvas.style.left = '0';
        bgCanvas.style.zIndex = '-1';
        document.body.appendChild(bgCanvas);
    }
    
    // Initialize all game systems BEFORE the loading screen
    audioManager.init();
    particleSystem.init();
    backgroundEffects.init(); // find the canvas
    distractionMovement.init(); 
    distractionMovement.init();
    screenShake.init();
    achievementSystem.init();
    
    // Initialize Three.js if container exists
    const threeContainer = document.getElementById('threeContainer');
    if (threeContainer) {
        threeManager.init();
    }
    
    setupEventListeners();
    updateHUD();
    
    // Set dynamic loading tip
    updateLoadingTip();
    
    let progress = 0;
    const loadingInterval = setInterval(() => {
        progress += 10;
        document.getElementById('loadingProgress').style.width = progress + '%';
        
        if (progress >= 100) {
            clearInterval(loadingInterval);
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                showScreen('startScreen');
                console.log('✅ Game initialized with dynamic movement system');
            }, 500);
        }
    }, 100);
}

// Start when page loads
window.addEventListener('load', init);

// Add event listeners for touch/click
document.addEventListener('click', (e) => {
    if (gameState.gameRunning && e.target.closest('.distraction')) {
        return;
    }
});

console.log('🎮 Endless Embrace Game - with Audio, Particles & Three.js');
console.log('✅ All systems integrated and operational');

</script>
</body>
</html>